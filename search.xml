<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TCP 如何保证可靠传输</title>
    <url>/2021/07/22/TCP%20%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<p>写在前面：TCP 协议传输的特点主要就是面向字节流、传输可靠、面向连接。这篇文章就来分析一下 TCP 协议是如何保证传输的可靠性的。</p>
<ul>
<li>校验和</li>
<li>序列号</li>
<li>确认应答</li>
<li>重传机制</li>
<li>连接管理</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<h1 id="确认应答和序列号"><a href="#确认应答和序列号" class="headerlink" title="确认应答和序列号"></a>确认应答和序列号</h1><img src="./tcp8.png" width="75%" height="75%" />

<p>序列号：TCP 传输时将每个字节的数据都进行了编号，这就是序列号。每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。</p>
<p>确认应答：指下一次「期望」收到的数据的序列号，即当前收到的序列号 + 1。发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决不丢包的问题。</p>
<h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><p>在错综复杂的网络，数据传输并不一定能像预想的那么顺利，万一数据在传输过程中丢失了呢？所以 TCP 针对数据包丢失的情况，会用<font color='red'>重传机制</font>解决。</p>
<h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>重传机制的方式之一，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<font color='red'>超时重传</font>。</p>
<p>TCP 会在一下两种情况发生超时重传：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<img src="./tcp9.png" width="75%" height="75%" />

<blockquote>
<p><strong>超时时间应该设置为多少呢？</strong></p>
</blockquote>
<p>我们先来了解一下什么是 <code>RTT</code> （Round-Trip Time 往返时延），从下图我们就可以知道：</p>
<img src="./tcp10.png" width="75%" height="75%" />

<p><code>RTT</code> 就是数据从网络一端传送到另一端所需的时间，也就是<font color='red'>包的往返时间</font>。</p>
<p>超时重传时间是以 <code>RTO</code> （Retransmission Timeout 超时重传时间）表示。</p>
<p>假设在重传的情况下，超时时间 RTO 「较长或较短」时，会发生什么事情呢？</p>
<img src="./tcp11.png" width="75%" height="75%" />

<p>上图中有两种超时时间不同的情况：</p>
<ul>
<li>当超时时间 <font color='red'>RTO 较大</font>时，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>当超时时间 <font color='red'>RTO 较小</font>时，会导致可能并没有丢就重发，于是重发的就快，就会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>精确的测量超时时间 <code>RTO</code> 的值是非常重要的，这可让我们的重传机制更高效。</p>
<p>实际上，<font color='red'>超时重传时间 RTO 略大于报文往返时间 RTT</font>。</p>
<img src="./tcp12.png" width="75%" height="75%" />

<p>而且「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个动态变化的值。</p>
<p>在 Linux 中（BSD Unix 和 Windows 下也是这样）超时以 500ms 为一个单位进行控制，如果超时重发的数据再次超时的时候，又需要重传的时候，TCP 的策略是<font color='red'>超时间隔加倍</font>。</p>
<p>也就是<font color='red'>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送</font>。</p>
<p>超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？</p>
<p>于是就可以用「快速重传」机制来解决超时重发的时间等待。</p>
<h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>TCP 还有另外一种快速重传机制，它不以时间为驱动，而是以数据驱动重传。</p>
<p>怎么理解这句话呢，看图。</p>
<img src="./tcp13.png" width="75%" height="75%" />

<p><code>seq2</code> 发送后，由于某些原因，发送方没有收到 <code>ack3</code> 回应包。于是乎，后面发送 <code>seq3</code>、<code>seq4</code>、<code>seq5</code> 依然回的是 <code>ack2</code>。</p>
<p>发送方收到三个 <code>ack2</code> 后，知道 <code>seq2</code> 对方没有收到，就会在定时器过期之前，重传丢失的 <code>seq2</code>。</p>
<p>最后，收到 <code>seq2</code> 后，因为此时 <code>seq3、4、5</code> 都收到了，所以回复 <code>ack6</code>。</p>
<p>所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。但是依然面临一个问题，就是<font color='red'>重传的时候，是重传之前的一个，还是重传所有</font>。</p>
<p>这两种情况都有可能出现，为了解决不知道该重传哪些 TCP 报文，于是就有 SACK 方法。</p>
<h2 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h2><p><code>SACK</code> 全称（Selective Acknowledgment 选择性确认）。</p>
<p>这种方法需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<font color='red'>可以将缓存的地图发送给发送方</font>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<font color='red'>只重传丢失的数据</font>。</p>
<p>如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。</p>
<img src="./tcp14.png" width="75%" height="75%" />

<p>如果要支持 <code>SACK</code> ，必须双方都要支持。在 Linux 下，可以通过 <code>net.ipv4.tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）。</p>
<h2 id="Duplicate-SACK"><a href="#Duplicate-SACK" class="headerlink" title="Duplicate SACK"></a>Duplicate SACK</h2><p>Duplicate SACK 又称 <code>D-SACK</code> ，其主要<font color='red'>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了</font>。</p>
<p>下面举例两个例子，来说明 <code>D-SACK</code> 的作用。</p>
<p><em><strong>例一：ACK 丢包</strong></em></p>
<img src="./tcp15.png" width="75%" height="75%" />

<ul>
<li>「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）</li>
<li><font color='red'>于是「接收方」发现数据是重复收到的，于是回了一个 SACK = 3000<del>3500 </font>，告诉「发送方」 3000</del>3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 <code>D-SACK</code> 。</li>
<li>这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。</li>
</ul>
<p><em><strong>例二：网络延时</strong></em></p>
<img src="./tcp16.png" width="75%" height="75%" />

<ul>
<li>数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。</li>
<li>而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」。</li>
<li><font color='red'>所以「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包</font>。</li>
<li>这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。</li>
</ul>
<p>在 Linux 下可以通过 <code>net.ipv4.tcp_dsack</code> 参数开启/关闭这个功能（Linux 2.4 后默认打开）。</p>
<p><font color='red'>简单的概括一下，当 ACK 比 SACK 小的时候，意思就是接收端已经接受了这部分数据，告诉发送方不需要重发了。当 ACK 比 SACK 大的时候，意思就是这部分数据接收方已经重复接收了</font>。</p>
<h1 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h1><p><a href="https://zhengyiming0503.github.io/2021/07/20/%E6%B5%85%E8%B0%88%20TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">三次握手、四次挥手</a></p>
<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。</p>
<p>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p>
<p>为了解决这种现象发生，TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</p>
<img src="./tcp23.png" width="75%" height="75%" />

<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>TCP 使用的流量控制协议是可变大小的滑动窗口协议，我们先来认识一下滑动窗口。</p>
<blockquote>
<p><strong>引入窗口概念的原因</strong></p>
</blockquote>
<p>如果没有滑动窗口的话，根据 TCP 的发送应答机制，我们可以得出下图，必须等收到上一个数据包的应答包后，才再发送下一个数据包。</p>
<img src="./tcp17.png" width="75%" height="75%" />

<p>所以，这样的传输方式有一个缺点：数据包的<font color='red'>往返时间越长，通信的效率就越低</font>。</p>
<p>为了解决这个问题，TCP 引入了<font color='red'>窗口</font>这个概念。即使往返时间较长的情况下，它也不会降低网络通信的效率。</p>
<p>有了窗口，就可以指定窗口大小，窗口大小就是指<font color='red'>无需等待确认应答，而可以继续发送数据的最大值</font>。</p>
<p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓存区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<p>假设窗口大小为 <code>3</code> 个 TCP 段，那么发送方就可以「连续发送」 <code>3</code> 个 TCP 段，即使中途有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：</p>
<img src="./tcp18.png" width="75%" height="75%" />

<p>图中 ACK 600 丢失，但是通过下一次确认应答的 ACK 700 就可以确认 700 之前的数据都收到了。这个模式叫做<font color='red'>累计确认</font>或者<font color='red'>累计应答</font>。</p>
<blockquote>
<p><strong>窗口大小由哪一方决定？</strong></p>
</blockquote>
<p>发送端是根据接收端的处理能力来发送数据的，所以窗口的大小是由接收方的窗口大小来决定的。发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>
<blockquote>
<p><strong>发送方的滑动窗口</strong></p>
</blockquote>
<p>先来看看发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分：</p>
<img src="./tcp19.png" width="75%" height="75%" />

<ul>
<li>#1 是已发送并收到 ACK 确认的数据：1~31 字节；</li>
<li>#2 是已发送但未收到 ACK 确认的数据：32~45 字节；</li>
<li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51 字节；</li>
<li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52 字节以后；</li>
</ul>
<p>在下图，当发送方把数据全部都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没有收到 ACK 确认之前是无法继续发送数据了。</p>
<img src="./tcp20.png" width="75%" height="75%" />

<p>在下图，当收到之前发送的数据 <code>32~36</code> 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则<font color='red'>滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认</font>，接下来 <code>52~56</code> 字节又变成了可用窗口，那么后续也就可以发送 <code>52~56</code> 这 5 个字节的数据了。</p>
<img src="./tcp21.png" width="75%" height="75%" />

<blockquote>
<p><strong>接收方的滑动窗口</strong></p>
</blockquote>
<p>接下来我们看看接收方的窗口，接收窗口相对简单一些，根据处理的情况划分成三个部分：</p>
<img src="./tcp22.png" width="75%" height="75%" />

<ul>
<li>#1 + #2 是已经成功接收并确认的数据（等待应用程序读取）；</li>
<li>#3 是为收到数据但可以接收的数据；</li>
<li>#4 是未收到数据且不可以接收的数据；</li>
</ul>
<blockquote>
<p><strong>接收窗口和发送窗口的大小是相等的吗？</strong></p>
</blockquote>
<p>并不完全相等，只能说是两者约等于相等。</p>
<p>因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快，这样接收窗口就可以很快空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来通知发送方的。这个传输过程存在延时，所以接收窗口和发送窗口是约等于的关系。</p>
<h2 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h2><p>接收方向发送方通告窗口大小时，是通过 ACK 报文来通告的，如果当窗口大小为 0 时，就会阻止发送方给接收方传递数据，知道窗口变为非 0 为止，这就是窗口关闭。</p>
<blockquote>
<p><strong>窗口关闭潜在的危险</strong></p>
</blockquote>
<p>当发生窗口关闭时，接收方处理完数据后，就会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失，那麻烦就大了。</p>
<img src="./tcp24.png" width="75%" height="75%" />

<p>这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成死锁现象。</p>
<blockquote>
<p><strong>TCP 如何解决窗口关闭时，潜在的死锁现象呢？</strong></p>
</blockquote>
<p>TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</p>
<p>如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<img src="./tcp25.png" width="75%" height="75%" />

<ul>
<li>如果接收窗口仍然是 0，那么收到这个报文的一方就是重新启动持续计时器；</li>
<li>如果接收窗口不为 0，那么就成功打破了死锁局面。</li>
</ul>
<p>窗口探测的次数一般为 3 次，每次大约 30~60 秒。如果 3 次后窗口大小还是 0 的话，发送方会发送 RST 来断开连接。</p>
<h2 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h2><blockquote>
<p><strong>什么是糊涂窗口综合症</strong></p>
</blockquote>
<p>这个问题可以归结为小包的问题，就是由于发送端和接收端上的处理不一致，导致网络上产生很多的小包。在滑动窗口机制下，如果发送端和接收端速率很不一致，也会产生这种比较犯傻的状态：发送方发送的数据，只要一个大大的头部，携带数据很少。</p>
<p>对于接收端来讲，如果接收很慢，一次接收1个字节或者几个字节，这个时候接收端缓冲区很快就会被填满，然后窗口通告为 0 字节，这个时候发送端停止发送，应用程序收上去 1 个字节后，发出窗口通告为 1 字节，发送方收到通告之后，发出 1 个字节的数据，这样周而复始，传输效率会非常低。</p>
<p>同时如果发送端程序一次发送一个字节，虽然窗口足够大，但是发送仍是一个字节一个字节的传输，效率很低。</p>
<blockquote>
<p><strong>如何应对这个问题</strong></p>
</blockquote>
<p><em><strong>让接收方不通告小窗口给发送方</strong></em></p>
<p>接收方通常的策略如下：</p>
<p>当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 0 ，也就阻止了发送方再发数据过来。</p>
<p>等到接收方处理了一些数据后，窗口大小 &gt;= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。</p>
<p><em><strong>让发送方避免发送小数据</strong></em></p>
<p>发送方通常的策略：</p>
<p>使用 Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据：</p>
<ul>
<li>要等到窗口大小 &gt;= MSS 或是 数据大小 &gt;= MSS</li>
<li>收到之前发送数据的 ACK 包</li>
</ul>
<p>只要没满足上面条件中的一条，发送方一直在囤积数据，直到满足上面的发送条件。</p>
<p>另外，Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。</p>
<p>可以在 Socket 设置 <code>TCP_NODELAY</code> 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char *)&amp;value, sizeof(int));</span><br></pre></td></tr></table></figure>

<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><blockquote>
<p><strong>什么是拥塞控制，和流量控制有什么区别？</strong></p>
</blockquote>
<p>前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p>
<p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。</p>
<p><font color='red'>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大…</font></p>
<p>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</p>
<p>于是，就有了<font color='red'>拥塞控制</font>，控制的目的就是<font color='red'>避免「发送方」的数据填满整个网络</font>。为了在「发送方」调节所要发送数据的量，定义了一个叫做<font color='red'>「拥塞窗口」</font>的概念。</p>
<blockquote>
<p><strong>什么是拥塞窗口？和滑动窗口中的发送窗口有什么关系呢？</strong></p>
</blockquote>
<p><font color='red'>拥塞窗口 cwnd</font>是发送方维护的一个的状态变量，它会根据<font color='red'>网络的拥塞程度动态变化的</font>。</p>
<p>我们在前面提到过发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是 <code>swnd = min(cwnd, rwnd)</code>，也就是拥塞窗口和接收窗口中的最小值。</p>
<p>拥塞窗口 <code>cwnd</code> 变化的规则：</p>
<ul>
<li>只要网络中没有出现拥塞， <code>cwnd</code> 就会增大；</li>
<li>但网络中出现了拥塞， <code>cwnd</code> 就减少；</li>
</ul>
<blockquote>
<p><strong>那怎么知道当前网络是否出现了拥塞呢？</strong></p>
</blockquote>
<p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<font color='red'>发生了超时重传，就会认为网络出现了用拥塞</font>。</p>
<blockquote>
<p><strong>拥塞控制有哪些控制算法？</strong></p>
</blockquote>
<p>拥塞控制主要是四个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？</p>
<p>慢启动的算法记住一个规则就行：<font color='red'>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1</font>。</p>
<p>这里假定拥塞窗口 cwnd 和发送窗口 swnd 相等，下面举个例子：</p>
<ul>
<li>连接建立完成后，一开始初始化 cwnd = 1 ，表示可以传一个 MSS 大小的数据；</li>
<li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个；</li>
<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发 2 个，所以这一次能够发送 4 个；</li>
<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li>
</ul>
<img src="./tcp26.png" width="75%" height="75%" />

<p>可以发现慢启动算法是呈指数性增长的，当然也不是无限增长的。</p>
<p>有一个叫慢启动门限 <code>ssthresh</code> （slow start threshold）状态变量。</p>
<ul>
<li>当 cwnd &lt; ssthresh 时，使用慢启动算法。</li>
<li>当 cwnd &gt;= ssthresh 时，就会使用「拥塞避免算法」。</li>
</ul>
<h2 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h2><p>前面说道，当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。</p>
<p>一般来说 ssthresh 的大小是 65535 字节。</p>
<p>那么进入拥塞避免算法后，它的规则是：<font color='red'>每当收到一个 ACK 时，cwnd 增加 1/cwnd</font>。</p>
<p>接上前面的慢启动的栗子，现假定 ssthresh 为 8 ：</p>
<ul>
<li>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，<font color='red'>变成了线性增长</font>。</li>
</ul>
<img src="./tcp27.png" width="75%" height="75%" />

<p>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p>
<p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p>
<p>当触发了重传机制，也就进入了「拥塞发生算法」。</p>
<h2 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h2><p>之前介绍过主要两种重传机制：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
</ul>
<p>他们使用的拥塞发生算法是不同的：</p>
<p><em><strong>超时重传的拥塞发生算法</strong></em></p>
<p>当发生超时重传时，ssthresh 和 cwnd 的值会发生变化：</p>
<ul>
<li>ssthresh 变为 cwnd/2</li>
<li>cwnd 重置为 1</li>
</ul>
<img src="./tcp28.png" width="75%" height="75%" />

<p>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</p>
<p><em><strong>快速重传的拥塞发生算法</strong></em></p>
<p>前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p>
<p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：</p>
<ul>
<li>cwnd = cwnd/2 ，设置为原来的一半</li>
<li>ssthresh = cwnd</li>
<li>进入快速恢复算法</li>
</ul>
<h2 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h2><p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像超时重传那么强烈。</p>
<p>正如前面所说，进入快速恢复之前， cwnd 和 ssthresh 已被更新了：</p>
<ul>
<li>cwnd = cwnd/2 ，设置为原来的一半</li>
<li>ssthresh = cwnd</li>
</ul>
<p>然后，进入快速恢复算法：</p>
<ul>
<li>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
<img src="./tcp29.png" width="75%" height="75%" />

<p>也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>Http 知识点</title>
    <url>/2021/10/28/Http%20%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="HTTP-基本概念"><a href="#HTTP-基本概念" class="headerlink" title="HTTP 基本概念"></a>HTTP 基本概念</h1><blockquote>
<p><strong>HTTP 是什么？描述一下。</strong></p>
</blockquote>
<p>HTTP 是超文本传输协议，也就是 HyperText Transfer Protocol。在计算机世界里专门用来在<font color='red'>两点之间传输数据文字、图片、音频、视频等超文本数据</font>的约定和规范。</p>
<h1 id="HTTP-协议的特点"><a href="#HTTP-协议的特点" class="headerlink" title="HTTP 协议的特点"></a>HTTP 协议的特点</h1><p>HTTP 是一个属于应用层的面向对象的协议，有五大特点：</p>
<ol>
<li>支持客户/服务器模式；</li>
<li>简单快速；</li>
<li>灵活；</li>
<li><font color='red'>无连接</font>；</li>
<li><font color='red'>无状态</font>；</li>
</ol>
<blockquote>
<p><strong>无连接？</strong></p>
</blockquote>
<p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求后，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>因为服务器需要处理海量的网页访问，每个客户端与服务器之间交换数据的间歇性较大（即传输具有突发性、瞬时性），<font color='red'>大部分通道实际上会很空闲、无端占用资源</font> ，因此 HTTP 的设计者有意利用这种特点将协议设计为<font color='red'>请求时建立连接、请求完释放连接，以尽快将资源释放出来服务其他客户端</font>。</p>
<p>随时时间推移，网页变得越来越复杂，里面可能嵌入很多图片，这时候每次访问图片都需要建立一次 TCP 连接就显得很低效。后来，Keep-Alive 被提出用来解决这效率低的问题。</p>
<blockquote>
<p><strong>无状态?</strong></p>
</blockquote>
<p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求后，服务器根据请求会返回数据，但是不会记录任何信息。</p>
<p>HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，导致数据量增大。</p>
<p>两种保持 HTTP 连接状态的技术，Cookie 和 Session。</p>
<p>Cookie 可以保持登录信息到用户下次与服务器的会话，换句话说，下次访问同一网站时，用户不必再次输入用户名和密码了。还有一个重要的场景就是“购物车”，用户在网站不同的页面选择不同的商品，这些信息被写入 Cookie，以便在最后付款时提取信息。</p>
<p>Session 通过服务器来保持状态。当客户端访问服务器时，服务器根据需求设置 Session，将会话信息保存在服务器上，同时将标志 Session 的 SessionId 传递给客户端浏览器，浏览器将这个 SessionId 保存在内存中，我们称之为无过期时间的 Cookie。浏览器关闭后，这个 Cookie 就会被清掉，它不会存在于用户的 Cookie 临时文件。以后浏览器每次请求都会额外加上这个参数值，服务器会根据这个 SessionId，就能取得客户端的数据信息。</p>
<p>如果客户端浏览器意外关闭，服务器保存的 Session 数据不是立即释放，此时数据还会存在，只要我们知道那个 SessionId，就可以继续通过请求获得此 Session 的信息，因为此时后台的 Session 还存在，当然我们可以设置一个 Session 超时时间，一旦超过规定时间没有客户端请求时，服务器就会清除对应 SessionId 的 Session 信息。</p>
<blockquote>
<p>Cookie 和 Session 的区别？</p>
</blockquote>
<ol>
<li>Session 在服务器端，Cookie 在客户端。</li>
<li>Session 默认被存在在服务器的一个文件里（不是内存）。</li>
<li>session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）。</li>
<li>session 可以放在 文件、数据库、或内存中都可以。</li>
<li>用户验证这种场合一般会用 session。</li>
</ol>
<h1 id="HTTP-常见字段"><a href="#HTTP-常见字段" class="headerlink" title="HTTP 常见字段"></a>HTTP 常见字段</h1><p><code>Host</code> 客户端发生请求时，用来指定服务器域名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host: www.baidu.com</span><br></pre></td></tr></table></figure>

<p><code>Content-Length</code> 服务器返回数据时通过该字段，表面本次回应的数据长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Length: 1000</span><br></pre></td></tr></table></figure>

<p><code>Connection</code> 客户端要求服务器使用 TCP 持久连接，以便其他请求复用。HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive 。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p><code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>

<p><code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>

<h1 id="PUT-与-POST-方法的区别"><a href="#PUT-与-POST-方法的区别" class="headerlink" title="PUT 与 POST 方法的区别"></a>PUT 与 POST 方法的区别</h1><p><strong>一些狭窄的意见认为，POST方法用来创建资源，而PUT方法则用来更新资源。这个说法本身没有问题，但是并没有从根本上解释了二者的区别。事实上，它们最根本的区别就是：POST方法不是幂等的，而PUT方法则有幂等性。那这又衍生出一个问题，什么是幂等？</strong></p>
<p>幂等（idempotent、idempotence）是一个抽象代数的概念。在计算机中，可以这么理解，一个幂等操作的特点就是其任意多次执行所产生的影响均与依次一次执行的影响相同。</p>
<p>POST在请求的时候，服务器会每次都创建一个文件，但是在PUT方法的时候只是简单地更新，而不是去重新创建。因此PUT是幂等的。</p>
<h1 id="GET-与-POST-方法的区别"><a href="#GET-与-POST-方法的区别" class="headerlink" title="GET 与 POST 方法的区别"></a>GET 与 POST 方法的区别</h1><p>GET 方法的含义是请求从服务器获取资源。</p>
<p>POST 方法的含义是向 URL 指定的资源提交数据。</p>
<blockquote>
<p><strong>GET 和 POST 方法都是安全和幂等的吗？</strong></p>
</blockquote>
<ul>
<li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li>
<li>所谓的「幂等」，上面也有提到就是多次操作和一次操作所产生的影响是相同的。</li>
</ul>
<p>所以 GET 方法是 安全且幂等的，POST 方法不安全且不幂等。</p>
<h1 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h1><p>HTTP 定义了 5 类状态码，状态码由三位数字组成，第一个数字定义了响应的类别。</p>
<p><code>1XX</code> 提示信息 - 表示请求已被成功接收，还需要后续的操作。</p>
<p><code>2XX</code> 成功 - 报文已经收到并被正确处理。</p>
<p><code>3XX</code> 重定向 - 资源位置发生变动，需要客户端重新发送请求。</p>
<p><code>4XX</code> 客户端错误 - 请求报文有误，服务器无法处理。</p>
<p><code>5XX</code> 服务器端错误 - 服务器错误，服务器在处理请求时内部发生了错误。</p>
<hr>
<p>常见的状态码：</p>
<p>「200 OK」 最常见的成功状态码，服务器返回的响应头会有 body 数据。</p>
<p>「204 No Content」 与 200 OK 基本相同，但是没有 body 数据。</p>
<p>「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源</p>
<p>的全部，而是其中的一部分，也是服务器处理成功的状态。</p>
<p>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次</p>
<p>访问。</p>
<p>「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p>
<p>「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定</p>
<p>向，用于缓存控制。</p>
<p>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。</p>
<p>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。</p>
<p>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p>
<p>「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并</p>
<p>不知道。</p>
<p>「503 Service Unavailable」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍</p>
<p>后重试”的意思。</p>
<h1 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h1><blockquote>
<p><strong>HTTP 与 HTTPS 有哪些区别？</strong></p>
</blockquote>
<ol>
<li>HTTP 协议信息是明文传输，存在安全风险。HTTPS 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单，TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手后，还需要进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li>
<li>HTTP 端口号是 80，HTTPS 的端口号是 433。</li>
<li>HTTPS 需要向 CA (证书权威机构) 申请数字证书，来保证服务器的身份是可信的。</li>
</ol>
<blockquote>
<p><strong>HTTPS 解决了 HTTP 的哪些问题？</strong></p>
</blockquote>
<p>由于 HTTP 是明文传输，所以安全上存在以下三个风险：</p>
<ul>
<li>窃听风险，通信链路上获取通信内容，比如被抓包分析。</li>
<li>篡改风险，无法判断报文的完整性，可能遭到篡改，比如强制植入垃圾广告。</li>
<li>伪装风险，不验证通信方身份，因此有可能被伪装，比如冒充淘宝网站。</li>
</ul>
<img src="./https1.png" width="75%" height="75%" />

<p>HTTPS 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，可以很好的解决了上述的风险：</p>
<ul>
<li>信息加密：交互信息无法被窃取。</li>
<li>校验机制：无法篡改通信内容，篡改了就不能正常显示。</li>
<li>身份证书：保证服务器是可信的。</li>
</ul>
<blockquote>
<p><strong>具体是怎么实现的呢？</strong></p>
</blockquote>
<p>&lt;一&gt; 解决内容可能被窃听的问题–混合加密</p>
<p>采用混合加密的原因：</p>
<ul>
<li>「对称加密」只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交互。</li>
<li>「非对称加密」使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交互问题但速度慢。用公钥加密，用私钥解密。</li>
</ul>
<p>在通信建立前采用「非对称加密」的方式交互「会话密钥」，后续就不再使用「非对称加密」。</p>
<p>在通信过程中全部使用「对称加密」的「会话密钥」的方式加密明文数据。</p>
<p>&lt;二&gt; 解决报文可能遭篡改问题–摘要算法</p>
<p>「摘要算法」用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。</p>
<img src="./https2.png" width="75%" height="75%" />

<p>客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文的摘要，与客户端发送过来的摘要进行对比，如果相同则说明数据是完整的。</p>
<p>&lt;三&gt; 解决通信方身份可能被伪装的问题–数字证书认证</p>
<p>客户端先向服务器索要公钥，然后用公钥加密信息，服务器收到密文，用自己的私钥解密。</p>
<p>这就存在些问题，如何保证公钥不被篡改和信任度?</p>
<p>所以这里就需要借助第三方权威机构 <code>CA</code> （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p>
<img src="./https3.png" width="75%" height="75%" />

<p>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。</p>
<blockquote>
<p><strong>HTTPS 是如何建立连接的？期间交互了什么？</strong></p>
</blockquote>
<p>SSL/TLS 协议基本流程：</p>
<ul>
<li>客户端、服务器通过 <code>CA</code> 体系交换公钥。</li>
<li>通过非对称加密，交换用于对称加密的密钥。</li>
<li>双方采用对称加密算法，进行加密通信。</li>
</ul>
<hr>
<p>参考博客：</p>
<p><a href="https://www.cnblogs.com/TankXiao/archive/2012/02/13/2342672.html">https://www.cnblogs.com/TankXiao/archive/2012/02/13/2342672.html</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/360519206">https://zhuanlan.zhihu.com/p/360519206</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>chromium 多线程模型分析</title>
    <url>/2021/09/25/chromium%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><strong>写在前面</strong>：相信很多人编程的痛点肯定包括多线程。执行顺序的不确定性，资源的并发访问一直都困扰着大家。相较于传统的锁编程，chromium 并不鼓励使用加锁机制。</p>
<h1 id="线程模型概述"><a href="#线程模型概述" class="headerlink" title="线程模型概述"></a>线程模型概述</h1><p><strong>设计原则</strong>：</p>
<ol>
<li>不在 UI 线程执行耗时操作，保证界面的流畅不卡顿。（解决方法：程序启动时起一个杂事线程-ThreadGlobalMisc，专门处理这些耗时操作）</li>
<li>少用锁和线程安全对象，设计上避免并发访问资源，对象只会存在一个线程，通过在线程之间传递消息实现线程间通信。（每个线程有一个任务队列，只有在队列中插入任务和取出任务时用到了锁）</li>
<li>线程之间不要互相阻塞。（每个线程都有自己的 eventloop 和 eventpump，处理本线程的任务）</li>
</ol>
<p>在程序启动时就创建预定用途的线程，后续就尽量使用已有线程，不要创建新的线程。</p>
<p><em><strong>栗子：一个异步通信过程</strong></em></p>
<img src="./chromium1.png" width="50%" height="50%" />

<p><font color='red'>一个线程请求另一个线程执行任务时，只需将任务封装成一个 <code>闭包-Closure</code> 投递到对方线程的任务队列即可</font>。</p>
<p>然后我解释一下上图的意思：</p>
<ol>
<li><p>A 线程从任务队列取出一个任务执行，这个任务就是 <code>task 1(1)</code>。</p>
</li>
<li><p>这个任务中需要 B 线程参与，于是将一个闭包投递给 B 线程执行，这个闭包对应的就是 <code>task 1(2)</code>。</p>
</li>
<li><p>在 B 线程执行的过程中，与此同时 A 线程就接着从自己的任务队列，取出下一个任务 <code>task 2</code> 继续执行。</p>
<p>到这步就是一个典型的异步通信过程了，如果 A 线程不需要知道 <code>task 1(2)</code> 的执行结果，就结束了。</p>
</li>
<li><p>A 线程如果需要知道异步通信的结果，B 线程在 <code>task 1(2)</code> 执行完后，再发一个闭包到 A 线程的任务队列即可。</p>
</li>
</ol>
<p>为了完成上述异步通信，线程的生命周期如下图：</p>
<img src="./chromium2.png" width="75%" height="75%" />

<p><font color='red'>线程在启动后，就围绕着一个任务队列不断地进行循环，直到线程关闭。在循环期间，不断地检查队列是否为空，不为空就取出 <code>任务-Task</code> 执行，如果为空，可以通过条件变量锁将线程沉睡，当有新的任务插入队列时，再将线程唤醒</font>。</p>
<p>所以，一个线程如果请求另外一个线程执行某一操作，只需将操作封装成任务投递到目标线程的任务队列即可。</p>
<p>这种基于任务队列的线程运行模式，要求在对问题进行建模时，提前知道执行者。在设计数据结构时，就已经规定了这些数据仅仅会被执行者访问，所以就不需要加锁操作了。这就是 chromium 通过任务队列实现异步通信的多线程模型的设计哲学（爱了）。</p>
<blockquote>
<p><strong>啥是闭包？</strong></p>
</blockquote>
<p>闭包的定义是：一个函数和它所引用的非本地变量（非 lambda 表达式内部定义的变量）的一个集合。</p>
<p>通俗的说，就是利用了 lambda 表达式可访问上下文环境从而实现的一个可调用对象。</p>
<p><em><strong>举个栗子</strong></em>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 伪代码</span><br><span class="line">typedef std::function&lt;void(void)&gt; StdClosure;</span><br><span class="line"></span><br><span class="line">class CTestClosure</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void fun1();</span><br><span class="line">	void fun2();</span><br><span class="line">	void Test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CTestClosure::Test()</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	StdClosure closure = [this]() &#123;</span><br><span class="line">		...</span><br><span class="line">		fun1();</span><br><span class="line">		fun2();</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	ThreadManager::PostTask(kThreadGlobalMisc, ToWeakCallback(closure));</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们分析一下这个栗子里的伪代码：</p>
<ul>
<li><p>通过 lambda 表达式的 this 捕获，可以在表达式中使用这个对象的成员函数和成员变量。</p>
</li>
<li><p>把这个闭包投递到 misc 杂事线程中。</p>
<p><font color='red'>需要注意一点就是，必须保证在执行这个任务时，对象还没有被销毁。所以在这里使用了 weakcallback 弱回调。原理就是利用 <code>weak_ptr</code> 管理对象生命周期，利用它的 <code>expired()</code> 函数判断对象是否过期，如果没过期才能进行调用</font>。</p>
</li>
</ul>
<h1 id="线程模型实现"><a href="#线程模型实现" class="headerlink" title="线程模型实现"></a>线程模型实现</h1><p>代码分析的是网易 nbase 线程库，这个库是参考 chromium 线程模型实现的。</p>
<p>注：由于小明并不是这个库的作者，而是在学习源码时做出的总结，如果有讲错的地方请多担待。</p>
<img src="./chromium3.png" width="100%" height="100%" />

<p>小明简单的画了一个图，咱们先大概的讲下每个类的作用。</p>
<ul>
<li><code>ThreadManager</code>：这个一个全局的单例类，管理所有的线程。</li>
<li><code>FrameworkThread</code>：线程类，我们创建的线程类需要从这个类派生出来。</li>
<li><code>MessageLoop</code>：消息循环，每个线程有且只有一个消息循环。负责维护任务队列，响应 MessgaePump 回调时处理任务队列。</li>
<li><code>MessageLoopProxy</code>：消息循环代理，提供跨线程安全访问 MessageLoop 的机制，非本线程内的 PostTask 族函数必须通过 MessageLoopProxy 调用。</li>
<li><code>MessagePump</code>：消息泵，负责起消息循环，调度 MessageLoop。</li>
<li><code>MessagePump::Delegate</code>：这个类定义了一组接口，由 MessageLoop 实现，MessagePump 通过这组接口来触发 MessageLoop 执行特定的任务。</li>
</ul>
<h2 id="线程：从创建到运行、添加任务"><a href="#线程：从创建到运行、添加任务" class="headerlink" title="线程：从创建到运行、添加任务"></a>线程：从创建到运行、添加任务</h2><p>下面以一个普通的线程为例，来看看线程从创建到执行的过程。</p>
<ol>
<li><p>创建一个 FrameworkThread 对象，调用成员函数 Start 启动一个线程，成员函数 Run 作为线程的入口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在 windows 平台下创建一个线程</span><br><span class="line">bool Thread::Create()</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	// create thread first</span><br><span class="line">	thread_handle_ = (HANDLE)_beginthreadex(NULL,</span><br><span class="line">		0, ThreadProcFunc, this, 0, (unsigned*)&amp;thread_id_);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>FrameworkThread 类的成员函数 Run 负责创建消息循环，也就是给这个线程创建一个 MessageLoop 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void FrameworkThread::Run()</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    MessageLoop *message_loop;</span><br><span class="line">    if (loop_type_ == MessageLoop::kCustomMessageLoop)</span><br><span class="line">    	message_loop = factory_-&gt;CreateMessageLoop();</span><br><span class="line">    else &#123;</span><br><span class="line">    	if (loop_type_ == MessageLoop::kIOMessageLoop)</span><br><span class="line">    		message_loop = new IOMessageLoop;</span><br><span class="line">    	else if (loop_type_ == MessageLoop::kUIMessageLoop)</span><br><span class="line">    		message_loop = new UIMessageLoop;</span><br><span class="line">    &#125;</span><br><span class="line">    message_loop_ = message_loop;</span><br><span class="line">	...</span><br><span class="line">    Init();</span><br><span class="line">    message_loop_-&gt;RunWithDispatcher(dispatcher_);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MessageLoop 类在创建消息循环的过程中，会创建一个消息泵 MessagePump 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MessageLoop::MessageLoop()</span><br><span class="line">	: type_(kDefaultMessageLoop),</span><br><span class="line">	  state_(NULL),</span><br><span class="line">#if defined(OS_WIN)</span><br><span class="line">	  os_modal_loop_(false),</span><br><span class="line">#endif // OS_WIN</span><br><span class="line">	  nestable_tasks_allowed_(true),</span><br><span class="line">	  next_delayed_task_sequence_num_(0)</span><br><span class="line">&#123;</span><br><span class="line">	// 一个线程内不能存在两个或以上MessageLoop</span><br><span class="line">	assert(g_lazy_ptr.Pointer()-&gt;Get() == NULL);</span><br><span class="line">	// 默认消息循环</span><br><span class="line">	if (type_ == kDefaultMessageLoop)</span><br><span class="line">		pump_.reset(new DefaultMessagePump);</span><br><span class="line">	g_lazy_ptr.Pointer()-&gt;Set(this);</span><br><span class="line"></span><br><span class="line">	message_loop_proxy_.reset(new MessageLoopProxy, &amp;MessageLoopProxyTraits::Destruct);</span><br><span class="line">	message_loop_proxy_-&gt;target_message_loop_ = this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消息循环创建完成后，调用 MessageLoop 类的成员函数 Run 或者 RunWithDispatcher，从而调用 MessagePump 的 Run 函数启动消息循环。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void MessageLoop::RunInternal()</span><br><span class="line">&#123;</span><br><span class="line">	assert(this == current());</span><br><span class="line"></span><br><span class="line">#if defined(OS_WIN)</span><br><span class="line">	if (state_-&gt;dispatcher &amp;&amp; type() == kUIMessageLoop)</span><br><span class="line">	&#123;</span><br><span class="line">		static_cast&lt;WinUIMessagePump *&gt;(pump_.get())-&gt;</span><br><span class="line">			RunWithDispatcher(this, state_-&gt;dispatcher);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	pump_-&gt;Run(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>到此，一个带消息循环的线程就创建成功了，然后我们要做的就是往线程的任务队列中投递任务。方法是通过  MessageLoop 对象的 PostTask族函数：</p>
<ol>
<li>PostTask：添加需要马上处理的并且可以在嵌套消息循环中处理的任务。</li>
<li>PostDelayedTask：添加需要延迟处理的并且可以在嵌套消息循环中处理的任务。</li>
<li>PostNonNestableTask：添加需要马上处理的并且不可以在嵌套消息循环中处理的任务。</li>
<li>PostNonNestableDelayedTask：添加需要延迟处理的并且不可以在嵌套消息循环中处理的任务。</li>
</ol>
<blockquote>
<p><strong>解释一下“嵌套任务”的意思：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 如果启用嵌套任务，那么Task将被立即执行，否则将先被暂存在一个队列中直到上层任务执行完成再执行</span><br><span class="line">// 典型的场景：</span><br><span class="line">// - 线程启动了一个MessageLoop</span><br><span class="line">// - 线程收到了一个Task，Task #1</span><br><span class="line">// - Task #1执行过程中弹出了一个MessageBox从而隐式地进入另一个MessageLoop，即MessageBox消息循环。</span><br><span class="line">// - 在MessageBox的MessageLoop尚未结束前，线程又收到了另一个Task，Task #2</span><br><span class="line">// - 如果此时嵌套任务处理被启用，那么Task #2将立即被执行（不管Task #1是否已经结束），</span><br><span class="line">//   否则，Task #2将在Task #1被执行完成后再在线程的MessageLoop中执行</span><br></pre></td></tr></table></figure></li>
<li><p>向线程的消息队列发送消息之后，需要唤醒线程，这是通过调用 MessagePump 类的成员函数 ScheduleWork 进行的。线程被唤醒后，就会调用 MessageLoop 类重写父类 MessagePump::Delegate 的两个成员函数 DoWork 和 DoDelayedWork 对任务队列的任务进行处理。如果没有任务处理，线程就进入闲置状态，此时调用 DoIdleWork 函数处理被缓存着的非嵌套任务。</p>
</li>
</ol>
<h2 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h2><p>Chromium 定义了 3 种消息循环以应对不同的场景。根据 MessageLoop 的类型，会实例化不同的 MessagePump，在 windows 环境下，有三种，分别是：</p>
<ul>
<li>DefaultMessagePump</li>
<li>WinUIMessagePump</li>
<li>WinIOMessagePump</li>
</ul>
<p>其中，DefaultMessagePump 只处理 <code>Task</code>。</p>
<p>WinUIMessagePump 能处理 <code>Task</code> 和 <code>windows 消息</code>。</p>
<p>WinIOMessagePump 能处理 <code>Task</code> 和 <code>IO 事件</code>。</p>
<p>不同的 Pump 使用不同的方式唤醒，DefaultPump 是等待Event信号量，UIPump 是阻塞在 GetMessage 上等待 Windows 消息，所以可以发送 Windows 消息唤醒。而 IOPump 是阻塞在 IO 完成端口上，那么只要模拟发送一个 IO 完成信息过去即可唤醒线程。</p>
<p>MessagePump 的 Run 函数是执行消息循环的过程，我们来分析下，是如何实现这些 Pump 的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void DefaultMessagePump::Run(Delegate* delegate)</span><br><span class="line">&#123;</span><br><span class="line">	// Quit must have been called outside of Run!</span><br><span class="line">	assert(should_quit_ == false);</span><br><span class="line"></span><br><span class="line">	for (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		bool did_work = delegate-&gt;DoWork();</span><br><span class="line">		if (should_quit_)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		did_work |= delegate-&gt;DoDelayedWork(&amp;delayed_work_time_);</span><br><span class="line">		if (should_quit_)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		if (did_work)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		did_work = delegate-&gt;DoIdleWork();</span><br><span class="line">		if (should_quit_)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		if (did_work)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		if (delayed_work_time_.is_null())</span><br><span class="line">		&#123;</span><br><span class="line">			Wait();</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			TimeDelta delay = delayed_work_time_ - TimeTicks::Now();</span><br><span class="line">			if (delay &gt; TimeDelta())</span><br><span class="line">				WaitTimeout(delay);</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				delayed_work_time_ = TimeTicks();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	should_quit_ = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WinUIMessagePump::DoRunLoop()</span><br><span class="line">&#123;</span><br><span class="line">	for (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		bool more_work_is_plausible = ProcessNextWindowsMessage();</span><br><span class="line">		if (state_-&gt;should_quit)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		more_work_is_plausible |= state_-&gt;delegate-&gt;DoWork();</span><br><span class="line">		if (state_-&gt;should_quit)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		more_work_is_plausible |=</span><br><span class="line">			state_-&gt;delegate-&gt;DoDelayedWork(&amp;delayed_work_time_);</span><br><span class="line">			</span><br><span class="line">		if (more_work_is_plausible &amp;&amp; delayed_work_time_.is_null())</span><br><span class="line">			KillTimer(message_hwnd_, reinterpret_cast&lt;UINT_PTR&gt;(this));</span><br><span class="line">		if (state_-&gt;should_quit)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		if (more_work_is_plausible)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		more_work_is_plausible = state_-&gt;delegate-&gt;DoIdleWork();</span><br><span class="line">		if (state_-&gt;should_quit)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		if (more_work_is_plausible)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		WaitForWork();  // Wait (sleep) until we have work to do again.</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WinIOMessagePump::DoRunLoop()</span><br><span class="line">&#123;</span><br><span class="line">	for (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		bool more_work_is_plausible = state_-&gt;delegate-&gt;DoWork();</span><br><span class="line">		if (state_-&gt;should_quit)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		more_work_is_plausible |= WaitForIOCompletion(0, NULL);</span><br><span class="line">		if (state_-&gt;should_quit)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		more_work_is_plausible |=</span><br><span class="line">				state_-&gt;delegate-&gt;DoDelayedWork(&amp;delayed_work_time_);</span><br><span class="line">		if (state_-&gt;should_quit)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		if (more_work_is_plausible)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		more_work_is_plausible = state_-&gt;delegate-&gt;DoIdleWork();</span><br><span class="line">		if (state_-&gt;should_quit)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		if (more_work_is_plausible)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		WaitForWork();  // Wait (sleep) until we have work to do again.</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Run 函数传进来的 delegate 就是 MessageLoop，它实现了 MessagePump::Delegate 接口。通过对比上面三个函数发现，不同的地方只是等待任务，唤醒线程方式不同，其它的部分就是调用 Delegate 实现的这三个函数。</p>
<p><em><strong>MessagePumpDefault</strong></em></p>
<p>这个 Pump 是最简单的，通过 Event 信号量唤醒，处理 Task 队列，处理延迟 Task 队列，再处理 IdleWork，如果没有 IdleTask 则线程进入睡眠状态，当有新任务到来时，唤醒线程。</p>
<p><em><strong>WinUIMessagePump</strong></em></p>
<p><font color='red'>Windows 程序是消息驱动的，每个 GUI 线程，系统会维护一个线程消息队列。当线程调用 GDI 函数时，系统会帮我们创建这个消息队列。</p>
<p>Windows 程序不管怎么封装，它的主线程肯定需要有如下这样的一个消息循环。</p>
<p>GetMessage 获得一条消息，然后调用 DispatchMessage 分发消息。DispatchMessage 首先找到消息对应的窗口，调用窗口的消息处理函数</font>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 消息循环</span><br><span class="line">MSG msg;</span><br><span class="line">while (GetMessage(&amp;msg, NULL, 0, 0))</span><br><span class="line">&#123;</span><br><span class="line">	TranslateMessage(&amp;msg);</span><br><span class="line">	DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这个 Pump 的实现相对复杂一点，需要在 loop 中处理 <code>Task 队列</code>和 <code>windows 消息队列</code>。所以我们就需要把这个 windows 消息循环给实现在这个 DoRunLoop 函数中。</p>
<p>看下伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(;;)</span><br><span class="line">&#123;</span><br><span class="line">	处理windows系统消息</span><br><span class="line"></span><br><span class="line">  	执行task队列中的一个task</span><br><span class="line"></span><br><span class="line">  	执行delayedTask队列中的一个task。</span><br><span class="line"></span><br><span class="line">  	if(还有其他任务（more_work_is_pausiable）), </span><br><span class="line">    	continue;</span><br><span class="line"> 	else</span><br><span class="line">   		挂起线程，等待消息进行唤醒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>处理 windows 消息</strong></p>
<p>循环先从 windows 的消息队列中提取下一条消息进行处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool more_work_is_plausible = ProcessNextWindowsMessage();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool WinUIMessagePump::ProcessNextWindowsMessage()</span><br><span class="line">&#123;</span><br><span class="line">	// If there are sent messages in the queue then PeekMessage internally</span><br><span class="line">	// dispatches the message and returns false. We return true in this</span><br><span class="line">	// case to ensure that the message loop peeks again instead of calling</span><br><span class="line">	// MsgWaitForMultipleObjectsEx again.</span><br><span class="line">	bool sent_messages_in_queue = false;</span><br><span class="line">	DWORD queue_status = ::GetQueueStatus(QS_SENDMESSAGE);</span><br><span class="line">	if (HIWORD(queue_status) &amp; QS_SENDMESSAGE)</span><br><span class="line">		sent_messages_in_queue = true;</span><br><span class="line"></span><br><span class="line">	MSG msg;</span><br><span class="line">	if (::PeekMessageW(&amp;msg, NULL, 0, 0, PM_REMOVE))</span><br><span class="line">		return ProcessMessageHelper(msg);</span><br><span class="line"></span><br><span class="line">	return sent_messages_in_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ProcessNextWindowsMessage 函数中主要处理 windows 的窗口消息，它的返回值表示输入队列中是否还有其他消息待处理，这样可以避免多调用一次 ::MsgWaitForMultipleObjectsEx。</p>
<p>ProcessMessageHelper 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool WinUIMessagePump::ProcessMessageHelper(const MSG&amp; msg)</span><br><span class="line">&#123;</span><br><span class="line">	if (WM_QUIT == msg.message)</span><br><span class="line">	&#123;</span><br><span class="line">		// Repost the QUIT message so that it will be retrieved by the primary</span><br><span class="line">		// GetMessage() loop.</span><br><span class="line">		state_-&gt;should_quit = true;</span><br><span class="line">		::PostQuitMessage(static_cast&lt;int&gt;(msg.wParam));</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// While running our main message pump, we discard kMsgHaveWork messages.</span><br><span class="line">	if (msg.message == kMsgHaveWork &amp;&amp; msg.hwnd == message_hwnd_)</span><br><span class="line">		return ProcessPumpReplacementMessage();</span><br><span class="line"></span><br><span class="line">	if (::CallMsgFilter(const_cast&lt;MSG*&gt;(&amp;msg), kMessageFilterCode))</span><br><span class="line">		return true;</span><br><span class="line"></span><br><span class="line">	PreProcessMessage(msg);</span><br><span class="line"></span><br><span class="line">	if (state_-&gt;dispatcher)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!state_-&gt;dispatcher-&gt;Dispatch(msg))</span><br><span class="line">			state_-&gt;should_quit = true;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		TranslateMessage(&amp;msg);</span><br><span class="line">		DispatchMessage(&amp;msg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PostProcessMessage(msg);</span><br><span class="line"></span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用基于 MessageLoop 的消息分发机制，可以减少无谓的线程创建，同时方便跨线程通信，值得借鉴。</p>
<p>由于小明水平有限，表达也不够好，本文内容有限，很多重要的地方可能都没有讲到。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>teamtalk学习笔记1：软件概述</title>
    <url>/2021/10/10/teamtalk%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%EF%BC%9A%E8%BD%AF%E4%BB%B6%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p><strong>写在前面</strong>：teamtalk 是 github 上开源的一个企业级即时通讯软件，网上也能找到很多对它的介绍。小明在刚参加工作的时候，作为一名 windows C++ 开发人员，只会使用 MFC 拖动控件，然后写一些业务逻辑代码。后来通过对这个开源项目的学习，我受益匪浅。</p>
<h1 id="编译部署"><a href="#编译部署" class="headerlink" title="编译部署"></a>编译部署</h1><p>代码有好多，包括服务端、pc端、mac、安卓、ios、web。因为我就学了 pc 端和服务端的代码，所以就讲这两部分。</p>
<p><em><strong>pc 端</strong></em></p>
<p>pc 端编译很简单，用 vs2013 找到 teamtalk.sln 文件，编译即可。</p>
<p>就像这个样子：</p>
<img src="./tt1.png" width="100%" height="100%" />

<p>现在还不能登录，因为还得部署服务端，并且在服务端上注册账号密码才行。</p>
<p><em><strong>服务端</strong></em></p>
<p>服务端部署就相对复杂很多了，特别是对于我这种对服务端开发没有开发经验的人。</p>
<p>网上找了两个博客：</p>
<p>一个是作者的：<a href="http://www.bluefoxah.org/teamtalk/new_tt_deploy.html">http://www.bluefoxah.org/teamtalk/new_tt_deploy.html</a></p>
<p>但是现在好像访问不了。我当时按照这个博客没有搭建成功。</p>
<p>第二个方法是网上的大神搞得一键部署工具：<a href="https://blog.csdn.net/waji2000/article/details/44925615">https://blog.csdn.net/waji2000/article/details/44925615</a></p>
<p>在虚拟机上安装最新的 CentOS 7 64 位，然后按着教程，最终部署成功。</p>
<p>如下图所示：</p>
<img src="./tt2.png" width="100%" height="100%" />

<p>注册好用户后，客户端就可以登录啦。</p>
<img src="./tt3.png" width="75%" height="75%" />

<p>登录后就是这个样子，我们现在就能通过源码去探索 teamtalk 的功能，和实现方法啦。本文到此结束，后续会对源码进行分析。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>teamtalk</tag>
      </tags>
  </entry>
  <entry>
    <title>teamtalk学习笔记2：基于观察者模式的模块封装</title>
    <url>/2021/10/11/teamtalk%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%EF%BC%9A%E5%9F%BA%E4%BA%8E%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p><strong>基于观察者模式的模块封装？</strong></p>
</blockquote>
<p>文章的标题有点拗口，我也没想到其它更好的名字，所以文章的开头我先花时间解释一下这是啥意思：</p>
<p>在 teamtalk 中，每个功能都被设计成了一个 <code>Module</code>，例如登录功能就有一个 <code>ILoginModule</code>，截屏功能则设计了 <code>IScreenCaptureModule</code>。</p>
<p>然后呢，所有的模块之间肯定不都是独立的，肯定会有些模块间有所关联，例如 A 模块的数据改动了，那么肯定要即时通知 B 模块进行相应的改动，所以这个模块又被设计了观察者模式的功能。</p>
<p>封装之后呢，就是一个被命名为 <code>ModuleBase</code> 的接口类，所有模块都从这个基类派生。（为了方便理解，我画了个草图，只看左半部分就好了，右半部分讲的是任务机制，跟本文无关，下一篇文章再将）。</p>
<img src="./tt4.png" width="100%" height="100%" />

<h1 id="ModuleSubject-目标类（被观察类）"><a href="#ModuleSubject-目标类（被观察类）" class="headerlink" title="ModuleSubject 目标类（被观察类）"></a>ModuleSubject 目标类（被观察类）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ModuleSubject final</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    /** @name Constructors and Destructor*/</span><br><span class="line"></span><br><span class="line">    //@&#123;</span><br><span class="line">    /**</span><br><span class="line">     * Constructor </span><br><span class="line">     */</span><br><span class="line">    ModuleSubject();</span><br><span class="line">    /**</span><br><span class="line">     * Destructor</span><br><span class="line">     */</span><br><span class="line">    ~ModuleSubject();</span><br><span class="line">    //@&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	void addObserver(IN void* pObserObject, IN MKODelegate handle);</span><br><span class="line">	void removeObserver(IN void* pObserObject);</span><br><span class="line">	void asynNotifyObserver(IN const std::string&amp; keyId);</span><br><span class="line">	void asynNotifyObserver(IN const std::string&amp; keyId, IN std::string&amp; mkoString);</span><br><span class="line">	void asynNotifyObserver(IN const std::string&amp; keyId, IN Int32 mkoInt);</span><br><span class="line">	void asynNotifyObserver(IN const std::string&amp; keyId, IN void* pmkoVoid);</span><br><span class="line">	void asynNotifyObserver(IN const std::string&amp; keyId, IN std::shared_ptr&lt;void&gt; pmkoShardVoid);</span><br><span class="line"></span><br><span class="line">	void getIObserverHandlersByModuleId(OUT std::vector&lt;MKODelegate&gt;&amp; vecMKOCallbacks);</span><br><span class="line">	BOOL isObserverExist(IN const void* pObserObject);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	void _removeAllObservers();</span><br><span class="line">	void _asynNotifyObserver(IN const std::string&amp; keyId, IN MKOEvent_Impl* pEvent);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	std::vector&lt;ModuleObserverCtx*&gt;	m_vecObservers;</span><br><span class="line">	CLock							m_lockObserver;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码很好理解，作为一个目标类，很常见的几个元素：</p>
<ul>
<li>观察者队列：m_vecObservers</li>
<li>添加观察者：addObserver</li>
<li>移除观察者：removeObserver</li>
<li>通知观察者：asynNotifyObserver</li>
</ul>
<blockquote>
<p><strong>添加观察者</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ModuleSubject::addObserver(IN void* pObserObject, IN MKODelegate handle)</span><br><span class="line">&#123;</span><br><span class="line">	if (isObserverExist(pObserObject))</span><br><span class="line">		return;</span><br><span class="line">	ModuleObserverCtx* pMkoCtx = new ModuleObserverCtx(handle, pObserObject);</span><br><span class="line">	&#123;</span><br><span class="line">		CAutoLock lock(&amp;m_lockObserver);</span><br><span class="line">		m_vecObservers.push_back(pMkoCtx);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的意思：先判断这个对象是否在队列中已经存在，如果不存在才添加到队列中。</p>
<blockquote>
<p><strong>移除观察者</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ModuleSubject::removeObserver(IN void* pObserObject)</span><br><span class="line">&#123;</span><br><span class="line">	std::vector&lt;ModuleObserverCtx*&gt; vecRemove;</span><br><span class="line">	CAutoLock lock(&amp;m_lockObserver);</span><br><span class="line">	auto iter = std::remove_if(m_vecObservers.begin(), m_vecObservers.end(), </span><br><span class="line">		[=](ModuleObserverCtx* pCtxItem)</span><br><span class="line">	&#123;</span><br><span class="line">		bool b = (pObserObject == pCtxItem-&gt;m_pObserverObject);</span><br><span class="line">		if (b)</span><br><span class="line">		&#123;</span><br><span class="line">			delete pCtxItem;</span><br><span class="line">			pCtxItem = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		return b;</span><br><span class="line">	&#125;</span><br><span class="line">	);</span><br><span class="line">	if (iter != m_vecObservers.end())</span><br><span class="line">	&#123;</span><br><span class="line">		m_vecObservers.erase(iter,m_vecObservers.end());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在观察者队列中判断是否存在这个观察者，如果存在则 delete 这个观察者对象，并且删除 m_vecObservers 数组中对应的指针。</p>
<blockquote>
<p><strong>通知观察者</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ModuleSubject::asynNotifyObserver(IN const std::string&amp; keyId)</span><br><span class="line">&#123;</span><br><span class="line">	MKOEvent_Impl* pEvent = new MKOEvent_Impl(this);</span><br><span class="line">	_asynNotifyObserver(keyId, pEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ModuleSubject::_asynNotifyObserver(IN const std::string&amp; keyId, IN MKOEvent_Impl* pEvent)</span><br><span class="line">&#123;</span><br><span class="line">	pEvent-&gt;m_keyId = keyId;</span><br><span class="line">	module::getEventManager()-&gt;asynFireUIEvent(pEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module::IMCoreErrorCode UIEventManager::asynFireUIEvent(IN const IEvent* const pEvent)</span><br><span class="line">&#123;</span><br><span class="line">	assert(m_hWnd);</span><br><span class="line">	assert(pEvent);</span><br><span class="line">	if (0 == m_hWnd || 0 == pEvent)</span><br><span class="line">		return IMCORE_ARGUMENT_ERROR;</span><br><span class="line"></span><br><span class="line">	if (FALSE == ::PostMessage(m_hWnd, UI_EVENT_MSG, reinterpret_cast&lt;WPARAM&gt;(this), reinterpret_cast&lt;WPARAM&gt;(pEvent)))</span><br><span class="line">		return IMCORE_WORK_POSTMESSAGE_ERROR;</span><br><span class="line"></span><br><span class="line">	return IMCORE_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MKOEvent_Impl::process()</span><br><span class="line">&#123;</span><br><span class="line">	if (nullptr == m_pMko)</span><br><span class="line">	&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	std::vector&lt;MKODelegate&gt; lstMKOCallbacks;</span><br><span class="line">	m_pMko-&gt;getIObserverHandlersByModuleId(lstMKOCallbacks);</span><br><span class="line">	if (lstMKOCallbacks.empty())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	for (MKODelegate callback : lstMKOCallbacks)</span><br><span class="line">	&#123;</span><br><span class="line">		try</span><br><span class="line">		&#123;</span><br><span class="line">			callback(m_keyId, std::make_tuple(m_mkoString, m_mkoInt, m_pmkoShardVoid, m_pmkoVoid));</span><br><span class="line">		&#125;</span><br><span class="line">		catch (const std::bad_function_call&amp;)</span><br><span class="line">		&#123;</span><br><span class="line">			LOG__(ERR,_T(&quot;bad function call-m_keyId:%d&quot;),m_keyId);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (...)</span><br><span class="line">		&#123;</span><br><span class="line">			LOG__(ERR, _T(&quot;unknown exception&quot;));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知观察者借助了 windows 消息队列从而实现异步调用，这样就不会阻塞住线程啦。</p>
<p>为了代码间的松耦合，所有任务类都继承自 <code>IEvent</code>，并且重写 <code>process</code> 函数。</p>
<p>你看下面代码，最终调用的就是 <code>pEvent-&gt;process()</code> ;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LRESULT _stdcall UIEventManager::_WindowProc(HWND hWnd</span><br><span class="line">											, UINT message</span><br><span class="line">											, WPARAM wparam</span><br><span class="line">											, LPARAM lparam)</span><br><span class="line">&#123;</span><br><span class="line">	switch (message)</span><br><span class="line">	&#123;</span><br><span class="line">	case UI_EVENT_MSG:</span><br><span class="line">		reinterpret_cast&lt;UIEventManager*&gt;(wparam)-&gt;_processEvent(reinterpret_cast&lt;IEvent*&gt;(lparam), TRUE);</span><br><span class="line">		break;</span><br><span class="line">	case WM_TIMER:</span><br><span class="line">		reinterpret_cast&lt;UIEventManager*&gt;(wparam)-&gt;_processTimer();</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	return ::DefWindowProc(hWnd, message, wparam, lparam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UIEventManager::_processEvent(IEvent* pEvent, BOOL bRelease)</span><br><span class="line">&#123;</span><br><span class="line">	assert(pEvent);</span><br><span class="line">	if (0 == pEvent)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	try</span><br><span class="line">	&#123;</span><br><span class="line">		pEvent-&gt;process();</span><br><span class="line">		if (bRelease)</span><br><span class="line">			pEvent-&gt;release();</span><br><span class="line">	&#125;</span><br><span class="line">	catch (imcore::Exception *e)</span><br><span class="line">	&#123;</span><br><span class="line">		LOG__(ERR, _T(&quot;event run exception&quot;));</span><br><span class="line">		pEvent-&gt;onException(e);</span><br><span class="line">		if (bRelease)</span><br><span class="line">			pEvent-&gt;release();</span><br><span class="line">		if (e)</span><br><span class="line">		&#123;</span><br><span class="line">			LOG__(ERR, _T(&quot;event run exception:%s&quot;), util::stringToCString(e-&gt;m_msg));</span><br><span class="line">			assert(FALSE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (...)</span><br><span class="line">	&#123;</span><br><span class="line">		LOG__(ERR, _T(&quot;operation run exception,unknown reason&quot;));</span><br><span class="line">		if (bRelease)</span><br><span class="line">			pEvent-&gt;release();</span><br><span class="line">		assert(FALSE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以最终在 <code>MKOEvent_Impl::process()</code> 这个函数中遍历了所有观察者，并且调用了每一个观察者注册的回调函数。</p>
<p>到此，一个从监听到触发的过程就完成啦。</p>
<h1 id="ModuleObserverCtx-观察者类"><a href="#ModuleObserverCtx-观察者类" class="headerlink" title="ModuleObserverCtx 观察者类"></a>ModuleObserverCtx 观察者类</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ModuleObserverCtx</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	ModuleObserverCtx(MKODelegate&amp; hd, void* pObserObject);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	void*					m_pObserverObject;</span><br><span class="line">	MKODelegate				callback;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>m_pObserverObject：是观察者对象的指针</li>
<li>callback：观察者注册的回调函数</li>
</ul>
<h1 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h1><p>封装之后使用起来还是很方便的。</p>
<p><em><strong>注册观察者</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module::getLoginModule()-&gt;addObserver(this,  BIND_CALLBACK_2(MainDialog::MKOForLoginModuleCallBack));</span><br></pre></td></tr></table></figure>

<p>这句代码的作用是主界面关注着登录模块的动向，回调函数是 <code>MainDialog::MKOForLoginModuleCallBack</code>。</p>
<img src="./tt5.png" width="100%" height="100%" />

<p><em><strong>通知观察者</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module::getLoginModule()-&gt;asynNotifyObserver(module::KEY_LOGIN_KICKOUT, Int32(imKickUser.kick_reason()));</span><br></pre></td></tr></table></figure>

<img src="./tt6.png" width="100%" height="100%" />

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>teamtalk</tag>
      </tags>
  </entry>
  <entry>
    <title>teamtalk学习笔记3：任务队列实现</title>
    <url>/2021/10/12/teamtalk%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%EF%BC%9A%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>客户端共有两个任务队列：</p>
<p>一个是逻辑任务队列，处理业务逻辑任务，另一个是 http 任务队列，处理 http 请求。</p>
<p>任务被抽象为一个对象，取名为 <code>Operation</code>。这是一个抽象类，所以的任务都需要从这个类派生，重写行为函数 <code>process</code>。这么做的好处就是降低了系统间的耦合度，而且新的任务很容易添加到系统中去。</p>
<p>这其实就是设计模式中的命令模式：请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p>
<img src="./tt7.png" width="100%" height="100%" />

<p>这三个类用法上的区别：</p>
<ul>
<li>ICallbackOperation：逻辑任务，可以携带一个回调函数。</li>
<li>LambdaOperation：逻辑任务，不能携带回调函数。</li>
<li>IHttpOperation：http 任务，可以携带一个回调函数。</li>
</ul>
<p>下面通过对登录模块的代码分析，讲清楚这两个队列的用法。</p>
<h1 id="HTTP-任务队列"><a href="#HTTP-任务队列" class="headerlink" title="HTTP 任务队列"></a>HTTP 任务队列</h1><p><strong>Http 任务队列通过一个线程池来处理任务</strong>。</p>
<blockquote>
<p><strong>添加 http 任务</strong></p>
</blockquote>
<img src="./tt9.png" width="100%" height="100%" />

<p>解释下这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 我把重要的几个函数都贴在了这里</span><br><span class="line">#define BIND_CALLBACK_1(func)   std::bind(&amp;func, this, placeholders::_1)</span><br><span class="line"></span><br><span class="line">typedef std::function&lt;void(std::shared_ptr&lt;void&gt;)&gt; IOperationDelegate;</span><br><span class="line"></span><br><span class="line">DoLoginServerHttpOperation::DoLoginServerHttpOperation(IN module::IOperationDelegate callback,IN DoLoginServerParam&amp; param)</span><br><span class="line">:IHttpOperation(callback)</span><br><span class="line">,m_param(param)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HttpPoolModule_Impl::pushHttpOperation(module::IHttpOperation* pOperaion, BOOL bHighPriority /*= FALSE*/)</span><br><span class="line">&#123;</span><br><span class="line">	if (NULL == pOperaion)</span><br><span class="line">	&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CAutoLock lock(&amp;m_mtxLock);</span><br><span class="line">	if (bHighPriority)</span><br><span class="line">		m_lstHttpOpers.push_front(pOperaion);</span><br><span class="line">	else</span><br><span class="line">		m_lstHttpOpers.push_back(pOperaion);</span><br><span class="line">	_launchThread();</span><br><span class="line">	::ReleaseSemaphore(m_hSemaphore, 1, NULL);</span><br><span class="line"></span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL HttpPoolModule_Impl::_launchThread()</span><br><span class="line">&#123;</span><br><span class="line">	if ((int)m_vecHttpThread.size() &gt;= MAX_THEAD_COUNT)</span><br><span class="line">	&#123;</span><br><span class="line">		return TRUE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TTHttpThread* pThread = new TTHttpThread();</span><br><span class="line">	PTR_FALSE(pThread);</span><br><span class="line">	if (!pThread-&gt;create())</span><br><span class="line">	&#123;</span><br><span class="line">		return FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	Sleep(300);</span><br><span class="line"></span><br><span class="line">	m_vecHttpThread.push_back(pThread);</span><br><span class="line"></span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BIND_CALLBACK_1</code> 是一个宏，通过函数适配器 <code>std::bind</code> 绑定一个函数，返回一个可调用实体，赋值给 <code>std::function</code>。</p>
<p>通过 <code>DoLoginServerHttpOperation</code> 的构造函数，可以发现 <code>LoginDialog::OnHttpCallbackOperation</code> 是这个任务的回调函数，<code>param</code> 是这个任务的参数，这两个都在 <code>process</code> 函数中使用。</p>
<p>通过 <code>pushHttpOperation</code> 添加 http 任务到队列中。</p>
<p><code>_launchThread</code> 函数：当线程池中线程数量没超过阈值时就创建线程。</p>
<h1 id="逻辑任务队列"><a href="#逻辑任务队列" class="headerlink" title="逻辑任务队列"></a>逻辑任务队列</h1><p><strong>逻辑任务队列简单一点，只有一个线程处理任务</strong>。</p>
<blockquote>
<p><strong>添加逻辑任务</strong></p>
</blockquote>
<img src="./tt12.png" width="100%" height="100%" />

<p>通过 <code>IMLibCoreStartOperation</code> 函数把任务添加到队列，你可以发现这个就比 http 的队列简单，没有用线程池，只是把任务放到逻辑任务队列 <code>m_vecRealtimeOperations</code> 中，然后调用条件变量 <code>notify_one</code> 唤醒对应的工作线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void IMLibCoreStartOperation(IN Operation* pOperation, Int32 delay /*= 0*/)</span><br><span class="line">&#123;</span><br><span class="line">	if (getOperationManager()-&gt;startOperation(pOperation, delay) != IMCORE_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		LOG__(ERR, _T(&quot;push operation failed&quot;));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">IMCoreErrorCode OperationManager::startOperation(IN Operation* pOperation, Int32 delay)</span><br><span class="line">&#123;</span><br><span class="line">	assert(pOperation);</span><br><span class="line">	if (0 == pOperation)</span><br><span class="line">	&#123;</span><br><span class="line">		return IMCORE_ARGUMENT_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//todo kuaidao...delay operntion process</span><br><span class="line">	if (delay &gt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt; locker(m_mutexOperation);</span><br><span class="line">		m_vecRealtimeOperations.push_back(pOperation);</span><br><span class="line">		m_CV.notify_one();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return IMCORE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>逻辑任务队列的处理线程</strong></p>
</blockquote>
<p>在主线程中启动一个任务队列处理线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMCoreErrorCode OperationManager::startup()</span><br><span class="line">&#123;</span><br><span class="line">	m_operationThread = std::thread([&amp;]</span><br><span class="line">	&#123;</span><br><span class="line">		std::unique_lock &lt;std::mutex&gt; lck(m_cvMutex);</span><br><span class="line">		Operation* pOperation = nullptr;</span><br><span class="line">		while (m_bContinue)</span><br><span class="line">		&#123;</span><br><span class="line">			if (!m_bContinue)</span><br><span class="line">				break;</span><br><span class="line">			if (m_vecRealtimeOperations.empty())</span><br><span class="line">				m_CV.wait(lck);</span><br><span class="line">			if (!m_bContinue)</span><br><span class="line">				break;</span><br><span class="line">			&#123;</span><br><span class="line">				std::lock_guard&lt;std::mutex&gt; lock(m_mutexOperation);</span><br><span class="line">				if (m_vecRealtimeOperations.empty())</span><br><span class="line">					continue;</span><br><span class="line">				pOperation = m_vecRealtimeOperations.front();</span><br><span class="line">				m_vecRealtimeOperations.pop_front();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (!m_bContinue)</span><br><span class="line">				break;</span><br><span class="line"></span><br><span class="line">			if (pOperation)</span><br><span class="line">			&#123;</span><br><span class="line">				pOperation-&gt;process();</span><br><span class="line">				pOperation-&gt;release();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	return IMCORE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了 lambda 表达式创建了一个线程，线程函数就是 lambda 表达式的内容：在一个 while 循环中，从任务队列中取出任务（如果队列为空，则使用条件变量 <code>wait</code> 使线程沉睡，当有新任务添加时，再唤醒线程），执行任务的行为函数 <code>process</code> （所有的任务都必须从基类 Operation 派生出来）。</p>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>创建任务 <code>Operation</code> 的时候我们有注册回调函数，我们可以在任务行为函数 <code>process</code> 中调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MODULE_CLASS ICallbackOpertaion : public imcore::Operation</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	ICallbackOpertaion(IOperationDelegate&amp; callback)</span><br><span class="line">		:m_callback(callback)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual ~ICallbackOpertaion() &#123;&#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">	/**</span><br><span class="line">	* 同步回调</span><br><span class="line">	*</span><br><span class="line">	* @param   std::shared_ptr&lt;void&gt; param</span><br><span class="line">	* @return  void</span><br><span class="line">	* @exception there is no any exception to throw.</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">	void syncCallback(std::shared_ptr&lt;void&gt; param)</span><br><span class="line">	&#123;</span><br><span class="line">		m_callback(param);</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	* 异步回调，借助UIEvent</span><br><span class="line">	*</span><br><span class="line">	* @param   std::shared_ptr&lt;void&gt; param</span><br><span class="line">	* @return  void</span><br><span class="line">	* @exception there is no any exception to throw.</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">	void asyncCallback(std::shared_ptr&lt;void&gt; param)</span><br><span class="line">	&#123;</span><br><span class="line">		CallbackOperationEvent* pEvent = new CallbackOperationEvent(m_callback, param);</span><br><span class="line">		module::getEventManager()-&gt;asynFireUIEvent(pEvent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	IOperationDelegate          m_callback;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module::IMCoreErrorCode UIEventManager::asynFireUIEvent(IN const IEvent* const pEvent)</span><br><span class="line">&#123;</span><br><span class="line">	assert(m_hWnd);</span><br><span class="line">	assert(pEvent);</span><br><span class="line">	if (0 == m_hWnd || 0 == pEvent)</span><br><span class="line">		return IMCORE_ARGUMENT_ERROR;</span><br><span class="line"></span><br><span class="line">	if (FALSE == ::PostMessage(m_hWnd, UI_EVENT_MSG, reinterpret_cast&lt;WPARAM&gt;(this), reinterpret_cast&lt;WPARAM&gt;(pEvent)))</span><br><span class="line">		return IMCORE_WORK_POSTMESSAGE_ERROR;</span><br><span class="line"></span><br><span class="line">	return IMCORE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回调函数有两种回调方式：同步和异步。</p>
<p>同步就直接在工作线程中直接调用回调函数。</p>
<p>异步则是通过 <code>windows 消息机制</code>，<code>postmessage</code> 把事件投递到主线程的 <code>windows 消息队列</code>。</p>
<h1 id="LambdaOperation"><a href="#LambdaOperation" class="headerlink" title="LambdaOperation"></a>LambdaOperation</h1><p>有没有这种情况，我们不需要知道任务的执行结果，这样也就不需要注册回调函数了。我们要做的仅仅是把任务投递到队列即可，不需要回调，这种情况下，重写一个 Operation 类显得太麻烦了。</p>
<p>于是我们就可以用 LambdaOperation。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMCoreErrorCode OperationManager::startOperationWithLambda(std::function&lt;void()&gt; operationRun</span><br><span class="line">                                                            , Int32 delay</span><br><span class="line">                                                            , std::string oper_name)</span><br><span class="line">&#123;</span><br><span class="line">    LambdaOperation* pLambdaOper = new LambdaOperation(operationRun);</span><br><span class="line">    pLambdaOper-&gt;set_name(oper_name);</span><br><span class="line">    return startOperation(pLambdaOper, delay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们把 <code>operationRun</code> 包装到一个默认的 <code>LambdaOperation</code> 即可，省去了去写一个类的步骤。</p>
<p>使用的时候就很简单：</p>
<img src="./tt13.png" width="100%" height="100%" />





]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>teamtalk</tag>
      </tags>
  </entry>
  <entry>
    <title>teamtalk学习笔记5：网络通信框架</title>
    <url>/2021/10/13/teamtalk%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%EF%BC%9A%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>TeamTalk 的网络库是典型的 Reactor 模式网络框架：非阻塞 IO + IO 多路复用 + 事件循环。程序的基本结构是一个事件循环（event loop），以事件驱动（event-driven）和事件回调的方式实现业务逻辑。windows 平台使用 select，Linux 平台使用 epoll。</p>
<p><strong>框架伪代码</strong>：</p>
<p>这个网络库实现起来还是相对简单的，是一个基础的单线程的 Reactor 模型网络库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(running)</span><br><span class="line">&#123;</span><br><span class="line">    // io 多路复用</span><br><span class="line">    int n = select(socket集合, ...);</span><br><span class="line">    </span><br><span class="line">    //事件处理</span><br><span class="line">    if (可读事件)</span><br><span class="line">    &#123;</span><br><span class="line">        pSocket-&gt;OnRead();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (可写事件)</span><br><span class="line">    &#123;</span><br><span class="line">        pSocket-&gt;OnWrite();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (异常)</span><br><span class="line">    &#123;</span><br><span class="line">        pSocket-&gt;OnClose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="事件分发器-CEventDispatch"><a href="#事件分发器-CEventDispatch" class="headerlink" title="事件分发器 CEventDispatch"></a>事件分发器 CEventDispatch</h1><p><code>CEventDispatch</code> 设计成一个单例类，是对 IO 多路复用的封装，在该类中启动一个事件循环，使用 select 或 epoll 管理所有文件描述符。</p>
<p>注：源码分析我以 select 为例，关于 epoll 我会在 muduo 网络库学习的文章中讲到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void CEventDispatch::StartDispatch(uint32_t wait_timeout)</span><br><span class="line">&#123;</span><br><span class="line">    fd_set read_set, write_set, excep_set;</span><br><span class="line">    timeval timeout;</span><br><span class="line">    timeout.tv_sec = 1; //wait_timeout 1 second</span><br><span class="line">    timeout.tv_usec = 0;</span><br><span class="line"></span><br><span class="line">    while (running)</span><br><span class="line">    &#123;</span><br><span class="line">        //_CheckTimer();</span><br><span class="line">        //_CheckLoop();</span><br><span class="line"></span><br><span class="line">        if (!m_read_set.fd_count &amp;&amp; !m_write_set.fd_count &amp;&amp; !m_excep_set.fd_count)</span><br><span class="line">        &#123;</span><br><span class="line">            Sleep(MIN_TIMER_DURATION);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_lock.lock();</span><br><span class="line">        FD_ZERO(&amp;read_set);</span><br><span class="line">        FD_ZERO(&amp;write_set);</span><br><span class="line">        FD_ZERO(&amp;excep_set);</span><br><span class="line">        memcpy(&amp;read_set, &amp;m_read_set, sizeof(fd_set));</span><br><span class="line">        memcpy(&amp;write_set, &amp;m_write_set, sizeof(fd_set));</span><br><span class="line">        memcpy(&amp;excep_set, &amp;m_excep_set, sizeof(fd_set));</span><br><span class="line">        m_lock.unlock();</span><br><span class="line"></span><br><span class="line">        if (!running)</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        //for (int i = 0; i &lt; read_set.fd_count; i++) &#123;</span><br><span class="line">        //  LOG__(NET,  &quot;read fd: %d\n&quot;, read_set.fd_array[i]);</span><br><span class="line">        //&#125;</span><br><span class="line">        int nfds = select(0, &amp;read_set, &amp;write_set, &amp;excep_set, &amp;timeout);</span><br><span class="line">        if (nfds == SOCKET_ERROR)</span><br><span class="line">        &#123;</span><br><span class="line">            //LOG__(NET,  &quot;select failed, error code: %d\n&quot;, GetLastError());</span><br><span class="line">            Sleep(MIN_TIMER_DURATION);</span><br><span class="line">            continue;           // select again</span><br><span class="line">        &#125;</span><br><span class="line">        if (nfds == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for (u_int i = 0; i &lt; read_set.fd_count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //LOG__(NET,  &quot;select return read count=%d\n&quot;, read_set.fd_count);</span><br><span class="line">            SOCKET fd = read_set.fd_array[i];</span><br><span class="line">            CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd);</span><br><span class="line">            if (pSocket)</span><br><span class="line">            &#123;</span><br><span class="line">                pSocket-&gt;OnRead();</span><br><span class="line">                pSocket-&gt;ReleaseRef();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (u_int i = 0; i &lt; write_set.fd_count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //LOG__(NET,  &quot;select return write count=%d\n&quot;, write_set.fd_count);</span><br><span class="line">            SOCKET fd = write_set.fd_array[i];</span><br><span class="line">            CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd);</span><br><span class="line">            if (pSocket)</span><br><span class="line">            &#123;</span><br><span class="line">                pSocket-&gt;OnWrite();</span><br><span class="line">                pSocket-&gt;ReleaseRef();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (u_int i = 0; i &lt; excep_set.fd_count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG__(NET,  _T(&quot;select return exception count=%d&quot;), excep_set.fd_count);</span><br><span class="line">            SOCKET fd = excep_set.fd_array[i];</span><br><span class="line">            CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd);</span><br><span class="line">            if (pSocket)</span><br><span class="line">            &#123;</span><br><span class="line">                pSocket-&gt;OnClose();</span><br><span class="line">                pSocket-&gt;ReleaseRef();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CEventDispatch 做的事情就是一开始讲的伪代码：启动一个 IO 线程，在线程中起一个循环，用 IO 多路复用技术去管理文件描述符，当事件来了执行相应的响应函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void CEventDispatch::AddEvent(SOCKET fd, uint8_t socket_event)</span><br><span class="line">&#123;</span><br><span class="line">    CAutoLock func_lock(&amp;m_lock);</span><br><span class="line"></span><br><span class="line">    if ((socket_event &amp; SOCKET_READ) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        FD_SET(fd, &amp;m_read_set);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    if ((socket_event &amp; SOCKET_WRITE) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        FD_SET(fd, &amp;m_write_set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((socket_event &amp; SOCKET_EXCEP) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        FD_SET(fd, &amp;m_excep_set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们有需要监听的文件描述符，只需要调用 <code>CEventDispatch::AddEvent</code> 函数即可，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CEventDispatch::Instance()-&gt;AddEvent(m_socket, SOCKET_ALL);</span><br></pre></td></tr></table></figure>

<h1 id="Socket-封装-CBaseSocket"><a href="#Socket-封装-CBaseSocket" class="headerlink" title="Socket 封装 CBaseSocket"></a>Socket 封装 CBaseSocket</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int CBaseSocket::Listen(const char* server_ip, uint16_t port, callback_t callback, void* callback_data)</span><br><span class="line">&#123;</span><br><span class="line">    m_local_ip = server_ip;</span><br><span class="line">    m_local_port = port;</span><br><span class="line">    m_callback = callback;</span><br><span class="line">    m_callback_data = callback_data;</span><br><span class="line"></span><br><span class="line">    m_socket = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">    if (m_socket == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;socket failed, err_code=%d\n&quot;, _GetErrorCode());</span><br><span class="line">        return NETLIB_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _SetReuseAddr(m_socket);</span><br><span class="line">    _SetNonblock(m_socket);</span><br><span class="line"></span><br><span class="line">    sockaddr_in serv_addr;</span><br><span class="line">    _SetAddr(server_ip, port, &amp;serv_addr);</span><br><span class="line">    int ret = ::bind(m_socket, (sockaddr*)&amp;serv_addr, sizeof(serv_addr));</span><br><span class="line">    if (ret == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG__(NET,  _T(&quot;bind failed, err_code=%d&quot;), _GetErrorCode());</span><br><span class="line">        closesocket(m_socket);</span><br><span class="line">        return NETLIB_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = listen(m_socket, 64);</span><br><span class="line">    if (ret == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG__(NET,  _T(&quot;listen failed, err_code=%d&quot;), _GetErrorCode());</span><br><span class="line">        closesocket(m_socket);</span><br><span class="line">        return NETLIB_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_state = SOCKET_STATE_LISTENING;</span><br><span class="line"></span><br><span class="line">    LOGA__(NET, &quot;CBaseSocket::Listen on %s:%d&quot;, server_ip, port);</span><br><span class="line"></span><br><span class="line">    AddBaseSocket(this);</span><br><span class="line">    CEventDispatch::Instance()-&gt;AddEvent(m_socket, SOCKET_READ | SOCKET_EXCEP);</span><br><span class="line">    return NETLIB_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也比较好理解：</p>
<p>_SetReuseAddr：设置地址可复用，防止 TIME_WAIT。</p>
<p>_SetNonblock：设置非阻塞 IO，通过 select 函数阻塞。</p>
<p>然后 bind，listen 之后把这个监听套接字 m_socket 放到 select 的队列里。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net_handle_t CBaseSocket::Connect(const char* server_ip, uint16_t port, callback_t callback, void* callback_data)</span><br><span class="line">&#123;</span><br><span class="line">    LOGA__(NET, &quot;CBaseSocket::Connect, server_ip=%s, port=%d&quot;, server_ip, port);</span><br><span class="line"></span><br><span class="line">    m_remote_ip = server_ip;</span><br><span class="line">    m_remote_port = port;</span><br><span class="line">    m_callback = callback;</span><br><span class="line">    m_callback_data = callback_data;</span><br><span class="line"></span><br><span class="line">    m_socket = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">    if (m_socket == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG__(NET,  _T(&quot;socket failed, err_code=%d&quot;), _GetErrorCode());</span><br><span class="line">        return NETLIB_INVALID_HANDLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _SetNonblock(m_socket);</span><br><span class="line">    _SetNoDelay(m_socket);</span><br><span class="line"></span><br><span class="line">    sockaddr_in serv_addr;</span><br><span class="line">    _SetAddr(server_ip, port, &amp;serv_addr);</span><br><span class="line">    int ret = connect(m_socket, (sockaddr*)&amp;serv_addr, sizeof(serv_addr));</span><br><span class="line">    if ( (ret == SOCKET_ERROR) &amp;&amp; (!_IsBlock(_GetErrorCode())) )</span><br><span class="line">    &#123;</span><br><span class="line">        LOG__(NET,  _T(&quot;connect failed, err_code=%d&quot;), _GetErrorCode());</span><br><span class="line">        closesocket(m_socket);</span><br><span class="line">        return NETLIB_INVALID_HANDLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_state = SOCKET_STATE_CONNECTING;</span><br><span class="line">    AddBaseSocket(this);</span><br><span class="line">    CEventDispatch::Instance()-&gt;AddEvent(m_socket, SOCKET_ALL);</span><br><span class="line">    </span><br><span class="line">    return (net_handle_t)m_socket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也很好理解：</p>
<p>connect 连接上服务端后，把这个通信套接字 m_socket 放到 select 队列里。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>上面有讲到文件描述符会监听三种事件，可读、可写、异常，事件来临之后肯定就需要执行回调函数啦。</p>
<p>我们以 read 为例讲一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void CBaseSocket::OnRead()</span><br><span class="line">&#123;</span><br><span class="line">    if (m_state == SOCKET_STATE_LISTENING)</span><br><span class="line">    &#123;</span><br><span class="line">        // 监听套接字，服务端才会走这里</span><br><span class="line">        _AcceptNewSocket();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        // 通信套接字</span><br><span class="line">        u_long avail = 0;</span><br><span class="line">        if ( (ioctlsocket(m_socket, FIONREAD, &amp;avail) == SOCKET_ERROR) || (avail == 0) )</span><br><span class="line">        &#123;</span><br><span class="line">            m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            m_callback(m_callback_data, NETLIB_MSG_READ, (net_handle_t)m_socket, NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>m_callback 是哪个函数呢，以客户端通信套接字为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void imconn_callback(void* callback_data, uint8_t msg, uint32_t handle, void* pParam)</span><br><span class="line">&#123;</span><br><span class="line">    NOTUSED_ARG(handle);</span><br><span class="line">    NOTUSED_ARG(pParam);</span><br><span class="line"></span><br><span class="line">    CImConn* pConn = TcpSocketsManager::getInstance()-&gt;get_client_conn(handle);</span><br><span class="line">    if (!pConn)</span><br><span class="line">    &#123;</span><br><span class="line">        //LOG__(NET, _T(&quot;connection is invalied:%d&quot;), handle);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    pConn-&gt;AddRef();</span><br><span class="line"></span><br><span class="line">    //  LOG__(NET,  &quot;msg=%d, handle=%d\n&quot;, msg, handle);</span><br><span class="line"></span><br><span class="line">    switch (msg)</span><br><span class="line">    &#123;</span><br><span class="line">    case NETLIB_MSG_CONFIRM:</span><br><span class="line">        pConn-&gt;onConnect();</span><br><span class="line">        break;</span><br><span class="line">    case NETLIB_MSG_READ:</span><br><span class="line">        pConn-&gt;OnRead();</span><br><span class="line">        break;</span><br><span class="line">    case NETLIB_MSG_WRITE:</span><br><span class="line">        pConn-&gt;OnWrite();</span><br><span class="line">        break;</span><br><span class="line">    case NETLIB_MSG_CLOSE:</span><br><span class="line">        pConn-&gt;OnClose();</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        LOG__(NET,  _T(&quot;!!!imconn_callback error msg: %d&quot;), msg);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pConn-&gt;ReleaseRef();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 select 模型检测到有数据时，会调用 imconn_callback，imconn_callback 中最终还是调用的 CImConn 接口，这里以接收数据为例，是 CImConn::OnRead（），代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void CImConn::OnRead()</span><br><span class="line">&#123;</span><br><span class="line">    for (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        uint32_t free_buf_len = m_in_buf.GetAllocSize() - m_in_buf.GetWriteOffset();</span><br><span class="line">        if (free_buf_len &lt; READ_BUF_SIZE)</span><br><span class="line">            m_in_buf.Extend(READ_BUF_SIZE);</span><br><span class="line"></span><br><span class="line">        int ret = netlib_recv(m_handle, m_in_buf.GetBuffer() + m_in_buf.GetWriteOffset(), READ_BUF_SIZE);</span><br><span class="line">        if (ret &lt;= 0)</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        m_in_buf.IncWriteOffset(ret);</span><br><span class="line">        while (m_in_buf.GetWriteOffset() &gt;= imcore::HEADER_LENGTH)</span><br><span class="line">        &#123;</span><br><span class="line">            uint32_t len = m_in_buf.GetWriteOffset();</span><br><span class="line">            uint32_t length = CByteStream::ReadUint32(m_in_buf.GetBuffer());</span><br><span class="line">            if (length &gt; len)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                imcore::TTPBHeader pbHeader;</span><br><span class="line">                pbHeader.unSerialize((byte*)m_in_buf.GetBuffer(), imcore::HEADER_LENGTH);</span><br><span class="line">                LOG__(NET, _T(&quot;OnRead moduleId:0x%x,commandId:0x%x&quot;), pbHeader.getModuleId(), pbHeader.getCommandId());</span><br><span class="line">                if (m_pTcpSocketCB)</span><br><span class="line">                    m_pTcpSocketCB-&gt;onReceiveData((const char*)m_in_buf.GetBuffer(), length);</span><br><span class="line">                LOGBIN_F__(SOCK, &quot;OnRead&quot;, m_in_buf.GetBuffer(), length);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (std::exception&amp; ex)</span><br><span class="line">            &#123;</span><br><span class="line">                assert(FALSE);</span><br><span class="line">                LOGA__(NET, &quot;std::exception,info:%s&quot;, ex.what());</span><br><span class="line">                if (m_pTcpSocketCB)</span><br><span class="line">                    m_pTcpSocketCB-&gt;onReceiveError();</span><br><span class="line">            &#125;</span><br><span class="line">            catch (...)</span><br><span class="line">            &#123;</span><br><span class="line">                assert(FALSE);</span><br><span class="line">                LOG__(NET, _T(&quot;unknown exception&quot;));</span><br><span class="line">                if (m_pTcpSocketCB)</span><br><span class="line">                    m_pTcpSocketCB-&gt;onReceiveError();</span><br><span class="line">            &#125;</span><br><span class="line">            m_in_buf.Read(NULL, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里依旧也是用了一个 while，来判断接收的数据是否一次性能够接受完。</p>
<p>对于接收到的数据首先通过 imcore::TTPBHeader::unSerialize 接口进行反序列化操作，然后再调用  m_pTcpSocketCB-&gt;onReceiveData，而 m_pTcpSocketCB 是我们前面通过 imcore::IMLibCoreRegisterCallback(m_socketHandle, this) 传进去的，最终还是进入到TcpClientModule_Impl::onReceiveData(const char* data, int32_t size)，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void TcpClientModule_Impl::onReceiveData(const char* data, int32_t size)</span><br><span class="line">&#123;</span><br><span class="line">    if (m_pServerPingTimer)</span><br><span class="line">        m_pServerPingTimer-&gt;m_bHasReceivedPing = TRUE;</span><br><span class="line"></span><br><span class="line">    imcore::TTPBHeader header;</span><br><span class="line">    header.unSerialize((byte*)data, imcore::HEADER_LENGTH); </span><br><span class="line">    if (IM::BaseDefine::CID_OTHER_HEARTBEAT == header.getCommandId() &amp;&amp; IM::BaseDefine::SID_OTHER == header.getModuleId())</span><br><span class="line">    &#123;</span><br><span class="line">        //模块器端过来的心跳包，不跳到业务层派发</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG__(NET, _T(&quot;receiveData message moduleId:0x%x,commandId:0x%x&quot;)</span><br><span class="line">        , header.getModuleId(), header.getCommandId());</span><br><span class="line"></span><br><span class="line">    if (g_seqNum == header.getSeqNumber())</span><br><span class="line">    &#123;</span><br><span class="line">        m_pImLoginResp-&gt;ParseFromArray(data + imcore::HEADER_LENGTH, size - imcore::HEADER_LENGTH);</span><br><span class="line">        ::SetEvent(m_eventReceived);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将网络包包装成任务放到逻辑任务队列里面去</span><br><span class="line">    _handlePacketOperation(data, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这个函数才是最上层注册的回调函数。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>teamtalk</tag>
      </tags>
  </entry>
  <entry>
    <title>teamtalk学习笔记4：线程池封装</title>
    <url>/2021/10/13/teamtalk%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<p>teamtalk 中 http 任务队列用到了一个线程池，通过这篇文章来看下是怎么封装的</p>
<ul>
<li>IHttpPoolModule：http 线程池抽象类</li>
<li>HttpPoolModule_Impl：http 线程池接口实现类</li>
<li>IHttpOperation：http 任务抽象类</li>
<li>TTThread：线程类封装</li>
<li>TTHttpThread：Http 线程类</li>
</ul>
<p>这几个是线程池模块使用到的类。</p>
<img src="./tt14.png" width="75%" height="75%" />

<p><em><strong>线程封装</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class UTILITY_CLASS TTThread</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    /** @name Constructors and Destructor*/</span><br><span class="line"></span><br><span class="line">    //@&#123;</span><br><span class="line">    /**</span><br><span class="line">     * Constructor </span><br><span class="line">     */</span><br><span class="line">    TTThread();</span><br><span class="line">    /**</span><br><span class="line">     * Destructor</span><br><span class="line">     */</span><br><span class="line">    ~TTThread();</span><br><span class="line">    //@&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	BOOL create();</span><br><span class="line">	void destory();</span><br><span class="line">	BOOL wait(DWORD dwWaitTime);</span><br><span class="line">	inline DWORD getThreadId() &#123; return m_dwThreadID; &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">	virtual UInt32 process();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	static UInt32 __stdcall _threadProc(void *lpParam);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	HANDLE		m_hThread;</span><br><span class="line">	DWORD		m_dwThreadID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOL TTThread::create()</span><br><span class="line">&#123;</span><br><span class="line">	m_hThread = (HANDLE)_beginthreadex(0,0, _threadProc, this, 0, (unsigned*)&amp;m_dwThreadID);</span><br><span class="line"></span><br><span class="line">	if (m_hThread &lt; (HANDLE)2)</span><br><span class="line">	&#123;</span><br><span class="line">		m_hThread = 0;</span><br><span class="line">		m_dwThreadID = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return m_hThread &gt;(HANDLE)1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用系统函数 <code>_beginthreadex</code> 创建线程，线程函数为 <code>_threadProc</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UInt32 __stdcall TTThread::_threadProc(void *lpParam)</span><br><span class="line">&#123;</span><br><span class="line">	TTThread* pThread = (TTThread*)lpParam;</span><br><span class="line">	assert(pThread);</span><br><span class="line">	if (pThread != 0)</span><br><span class="line">	&#123;</span><br><span class="line">		pThread-&gt;process();</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>_threadProc</code> 调用了 <code>process</code>，所以最终执行的线程函数为 <code>process</code>。所以我们使用的时候，只需要从 TTThread 派生出一个类，重写 <code>process</code> 函数，然后 <code>create</code> 创建线程即可。</p>
<p><em><strong>投递任务到任务队列</strong></em></p>
<p>线程池模块 <code>HttpPoolModule_Impl</code> 管理两个队列，一个任务队列，一个线程队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void HttpPoolModule_Impl::pushHttpOperation(module::IHttpOperation* pOperaion, BOOL bHighPriority /*= FALSE*/)</span><br><span class="line">&#123;</span><br><span class="line">	if (NULL == pOperaion)</span><br><span class="line">	&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    // 队列不是线程安全的所有需要加锁</span><br><span class="line">    // 使用信号量维护线程同步，信号量 + 1</span><br><span class="line">	CAutoLock lock(&amp;m_mtxLock);</span><br><span class="line">	if (bHighPriority)</span><br><span class="line">		m_lstHttpOpers.push_front(pOperaion);</span><br><span class="line">	else</span><br><span class="line">		m_lstHttpOpers.push_back(pOperaion);</span><br><span class="line">	_launchThread();</span><br><span class="line">	::ReleaseSemaphore(m_hSemaphore, 1, NULL);</span><br><span class="line"></span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL HttpPoolModule_Impl::_launchThread()</span><br><span class="line">&#123;</span><br><span class="line">	if ((int)m_vecHttpThread.size() &gt;= MAX_THEAD_COUNT)</span><br><span class="line">	&#123;</span><br><span class="line">		return TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 当线程池里的线程数没超过阈值，就增加线程</span><br><span class="line">	TTHttpThread* pThread = new TTHttpThread();</span><br><span class="line">	PTR_FALSE(pThread);</span><br><span class="line">	if (!pThread-&gt;create())</span><br><span class="line">	&#123;</span><br><span class="line">		return FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	Sleep(300);</span><br><span class="line"></span><br><span class="line">	m_vecHttpThread.push_back(pThread);</span><br><span class="line"></span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就做了两件事：</p>
<ol>
<li>投递任务到任务队列，信号量计数加 1。</li>
<li>判断当前线程池里的线程数，如果没超过阈值，就增加一个线程，放到线程池的队列中。</li>
</ol>
<p><em><strong>线程函数</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UInt32 TTHttpThread::process()</span><br><span class="line">&#123;</span><br><span class="line">	module::IHttpOperation * pHttpOper = NULL;</span><br><span class="line">	HttpPoolModule_Impl *pPool = m_pInstance;</span><br><span class="line">	while (m_bContinue)</span><br><span class="line">	&#123;</span><br><span class="line">		if (WAIT_OBJECT_0 != ::WaitForSingleObject(pPool-&gt;m_hSemaphore, INFINITE))</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!m_bContinue)</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			CAutoLock lock(&amp;(pPool-&gt;m_mtxLock));</span><br><span class="line">			if (pPool-&gt;m_lstHttpOpers.empty())</span><br><span class="line">				pHttpOper = NULL;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				pHttpOper = pPool-&gt;m_lstHttpOpers.front();</span><br><span class="line">				pPool-&gt;m_lstHttpOpers.pop_front();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try</span><br><span class="line">		&#123;</span><br><span class="line">			if (m_bContinue &amp;&amp; pHttpOper)</span><br><span class="line">			&#123;</span><br><span class="line">				pHttpOper-&gt;process();</span><br><span class="line">				pHttpOper-&gt;release();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (...)</span><br><span class="line">		&#123;</span><br><span class="line">			LOG__(ERR, _T(&quot;TTHttpThread: Failed to execute opertaion(0x%p)&quot;), pHttpOper);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当信号量计数小于等于 0 的时候，线程阻塞在 WaitForSingleObject 等待唤醒。</p>
<p>线程唤醒后，去任务队列取任务，然后执行。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>teamtalk</tag>
      </tags>
  </entry>
  <entry>
    <title>从输入网址到显示网页过程分析</title>
    <url>/2021/10/28/%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E7%BD%91%E9%A1%B5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><strong>写在前面</strong>：这是一个老生常谈的问题了，网上也有很多文章的。这两天我也看了好多篇文章，然后自己做个笔记。</p>
<p><strong>大致流程</strong>：</p>
<ol>
<li>URL 解析</li>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>响应 HTTP 请求</li>
<li>页面渲染</li>
</ol>
<h1 id="URL-解析"><a href="#URL-解析" class="headerlink" title="URL 解析"></a>URL 解析</h1><p>URL：统一资源定位符，俗称网页地址或者网址。表示某个资源的地址。</p>
<p>首先浏览器做的第一步工作就是要对 <code>URL</code> 进行解析，从而生成发送给 <code>Web</code> 服务器的请求信息。</p>
<img src="./url1.png" width="75%" height="75%" />

<p>所以图中的长长的 URL 实际上是请求服务器里的文件资源。</p>
<h1 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h1><p>DNS 实际上是一个域名和 IP 对应的数据库。</p>
<p>IP 地址往往都难以记住，但机器间互相只认识 IP 地址，于是人们发明了域名，让域名与 IP 地址直接一一对应，它们之间的转换工作称为域名解析，域名解析需要专门的域名解析服务器来完成，整个过程是自动进行的。</p>
<p>可以在浏览器中输入IP地址浏览网站，也可以输入域名查询网站，虽然得出的内容是一样的，但是调用的过程不一样，输入IP地址是直接从主机上调用内容，输入域名是通过域名解析服务器指向对应的主机的IP地址，再从主机调用网站的内容。</p>
<p>在进行 DNS 解析时，会经历以下步骤：</p>
<ol>
<li>检查浏览器缓存</li>
<li>检查系统缓存，检查 host 文件</li>
<li>发出一个 DNS 请求到本地 DNS 服务器。（本地 DNS 服务器一般都是你的网络接入服务器商提供，比如中国电信、中国移动）</li>
<li>如果本地 DNS 服务器还没有找到，会向 DNS 根服务器查询。但是根服务器没有记录具体的域名和 IP 地址的关系，而是告诉本地服务器去哪个域服务器上查询。</li>
<li>本地 DNS 服务器向域服务器发出请求，但是域服务器也不会返回域名和 IP 地址的对应关系，而是告诉本地 DNS 服务器，你的域名的解析服务器的地址。</li>
<li>最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</li>
</ol>
<p>最后我们通过一个图再来直观的看下域名解析的整个过程。</p>
<img src="./DNS 域名解析.png" width="75%" height="75%" />

<h1 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h1><h1 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h1><h1 id="响应-HTTP-请求"><a href="#响应-HTTP-请求" class="headerlink" title="响应 HTTP 请求"></a>响应 HTTP 请求</h1><h1 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h1><hr>
<p>参考博客：</p>
<p><a href="https://www.cnblogs.com/jin-zhe/p/11586327.html">https://www.cnblogs.com/jin-zhe/p/11586327.html</a></p>
<p><a href="https://www.cnblogs.com/yuanzhiguo/p/8119470.html">https://www.cnblogs.com/yuanzhiguo/p/8119470.html</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/360519206">https://zhuanlan.zhihu.com/p/360519206</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 TCP 三次握手、四次挥手</title>
    <url>/2021/07/20/%E6%B5%85%E8%B0%88%20TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h1 id="TCP-amp-UDP"><a href="#TCP-amp-UDP" class="headerlink" title="TCP&amp;UDP"></a>TCP&amp;UDP</h1><p>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。UDP 是一个简单的面向数据报的传输层通信协议。</p>
<blockquote>
<p><strong>TCP 和 UDP 区别？</strong></p>
</blockquote>
<ol>
<li>最大的区别就是「<code>连接</code>」vs「<code>无连接</code>」，TCP 面向连接，UDP 不建立连接。</li>
<li>服务对象。TCP 是一对一的两点服务，UDP 支持一对一、一对多、多对多的交互通信。</li>
<li>可靠性。TCP 是可靠的，数据可以无差错、不丢失、不重复。UDP 不可靠，发送之后就不管了，不保证能否安全送达。</li>
<li>TCP 有拥塞控制、流量控制保证数据传输的安全性，UDP 则没有。</li>
<li>传输方式。TCP 是字节流，UDP 是数据报。</li>
</ol>
<p>用一句话简单的概括就是：TCP 面向连接，可靠的字节流服务。提供超时重发、流量控制、拥塞控制等功能。UDP 不建立连接，不可靠，只是把数据包发给对应的ip地址，不能保证是否安全送达。</p>
<blockquote>
<p><strong>TCP 和 UDP 应用场景？</strong></p>
</blockquote>
<p>TCP 稳定可靠，适应场景：传送文件，发送邮件，浏览网页，UDP 速度快，但可能产生丢包，所以适用于对实时性要求较高，但对少量丢包没有太大要求的场景，比如域名查询，语音通话，视频直播</p>
<h1 id="TCP-报文格式"><a href="#TCP-报文格式" class="headerlink" title="TCP 报文格式"></a>TCP 报文格式</h1><img src="./tcp1.png" width="75%" height="75%" />

<p>TCP 报文头为 20 个字节。</p>
<p><code>序列号</code>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。</p>
<p><code>确认应答号</code>：指下一次「期望」收到的数据的序列号，即当前收到的序列号 + 1。发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决不丢包的问题。</p>
<p><code>控制位</code>：</p>
<ul>
<li>ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 协议规定，除了最初建立连接时的 SYN 包之外该位必须设置为 1。</li>
<li>RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li>SYN：在连接建立时用来同步序号，当 SYN = 1 而 ACK = 0时，表示这是一个连接请求报文。若服务器端同意建立连接，则在响应报文中使 SYN = 1，ACK = 1。</li>
<li>FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。</li>
</ul>
<p>顺便也讲下 UDP 的报文头部，见下图，比较简单，8 个字节。</p>
<img src="./tcp2.png" width="75%" height="75%" />

<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><img src="./tcp3.png" width="75%" height="75%" />

<blockquote>
<p><strong>描述三次握手过程。</strong></p>
</blockquote>
<ol>
<li>第一次握手 Client 发送 <code>SYN</code> 报文给 Server，序列号是随机生成的 <code>x</code> ，请求建立连接。</li>
<li>第二次握手 Server 发送 <code>SYN + ACK</code> 报文给 Client，序列号是随机生成的 <code>y</code>，确认序列号是当前收到的序列号 + 1，即 <code>x + 1</code> ，表示我收到了你的请求，并且我也请求建立连接。</li>
<li>第三次握手 Client 发送 <code>ACK</code> 报文给 Server，序列号 <code>x + 1</code>，确认序列号 <code>y + 1</code>，此时 TCP 连接就建立了。</li>
</ol>
<p>提一点就是，第三次握手是可以携带应用层数据的，前两次握手不行。</p>
<blockquote>
<p><strong>为什么是三次握手？不能两次握手？</strong></p>
</blockquote>
<p>目的是为了在不可靠的信道上建立可靠的连接，怎么理解这句话呢，举三个方面的例子：</p>
<ol>
<li><font color='red'>防止历史连接初始化造成混乱</font>。因为 TCP 协议的报文并不是按顺序到达的，比如网络拥堵了，客户端发了 2 次 SYN 包，如果是旧的 SYN 包先到达了，那服务端回的 ack 序号就有问题了，跟客户端最新的 syn 包序号对不上，所以客户端会 RST 断开这次连接。如果新的 SYN 包先到达，先建立连接了，旧的 SYN 包才到达，这样也有问题，服务端认为是两次连接，客户端觉得是同一个连接。所以三次握手是必须的。</li>
<li><font color='red'>双方同步初始序列号</font>。通过第二次握手，同步了序列号，所以客户端知道服务端成功接收了它的数据包。同理也需要第三次握手，也需要同步序列号，让服务端知道客户端成功接收了它的数据包。</li>
<li><font color='red'>防止伪造，验证源 IP</font>。如果有网络攻击，不断伪造 IP 向服务器发送请求连接，如果服务器不想被占用资源就需要通过第三次握手的内容鉴定。</li>
</ol>
<blockquote>
<p><strong>IP 层会分片，为什么 TCP 层还需要 MSS？</strong></p>
</blockquote>
<p>我们先来认识 MTU 和 MSS。</p>
<img src="./tcp4.png" width="75%" height="75%" />

<ul>
<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li>
<li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</li>
</ul>
<p>如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？</p>
<p>当 IP 层有超过一个 MTU 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU 。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上一层 TCP 传输层。</p>
<p>这样看起来井然有序，但这存在隐患的，<font color='red'>如果当一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</font>。</p>
<p>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。</p>
<p>当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。</p>
<p>因此，可以得知由 IP 层进行分片传输，是非常没有效率的。</p>
<p>所以，为了达到最佳的传输效能 TCP 协议在建立连接的时候通常要协商双方的 MSS 值，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU，自然也就不用 IP 分片了。</p>
<p>经过 TCP 层分片后，如果一个 TCP 分片丢失后，<font color='red'>进行重发时也是以 MSS 为单位</font>，而不用重传所有的分片，大大增加了重传的效率。</p>
<blockquote>
<p><strong>什么是 SYN 攻击？如何避免 SYN 攻击?</strong></p>
</blockquote>
<p><em><strong>SYN 攻击</strong></em></p>
<p>我们否知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同的 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 SYN 报文，就进入 SYN_RCVD 状态，但是服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的未完成连接队列，使得服务器不能为正常用户服务。</p>
<img src="./tcp5.png" width="75%" height="75%" />

<p><em><strong>我们再来了解下握手协议中的相关概念</strong></em></p>
<ul>
<li><p><strong>未完成连接队列和已完成连接队列</strong></p>
<p>服务端对于一个调用 listen 进行监听的套接字，操作系统会给这个套接字维护两个队列。</p>
<p>1.未完成连接队列</p>
<p>当客户端发送 TCP 三次握手的第一次握手「SYN」给服务器端时，服务器端就会在未完成队列中创建一个跟这个「SYN」对应的一项。我们可以把当前状态看成是半连接状态，此时服务端从 LISTEN 状态变成 SYN-RCVD 状态，同时给客户端回复第二次握手「SYN + ACK」，然后服务器等待第三次握手。</p>
<p>2.已完成连接队列</p>
<p>当第三次握手完成后，这个连接就变成了已建立状态 ESTABLISHED，每个已经完成三次握手的客户端都放在这个队列中。</p>
</li>
<li><p><strong>backlog 参数</strong></p>
<p>上面两个队列和的最大值，当这两个队列和超出 backlog 时，再有一个客户端发 SYN 请求，服务端不会给出响应。</p>
</li>
<li><p><strong>SYN-ACK 重传次数</strong></p>
<p>服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同。</p>
</li>
<li><p><strong>半连接存活时间</strong></p>
<p>是指半连接队列的条目存活的最长时间，也即服务从收到SYN包到确认这个报文无效的最长时间，该时间值是所有重传请求包的最长等待时间总和。有时我们也称半连接存活时间为Timeout时间、SYN_RECV存活时间。</p>
</li>
</ul>
<p><em><strong>SYN 攻击防范技术</strong></em></p>
<ul>
<li><p>增加最大半连接数</p>
</li>
<li><p>缩短超时时间</p>
</li>
<li><p>SYN cookies 技术</p>
<img src="./tcp6.png" width="75%" height="75%" />

<p>当「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」，</p>
<p>计算出一个 <code>cookie</code> 值，再以 SYN + ACK 中的「序列号」返回客户端，</p>
<p>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。</p>
<p>最后应用通过调用 <code>accpet()</code> socket 接口，从「Accept 队列」取出的连接。</p>
</li>
</ul>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><img src="./tcp7.png" width="75%" height="75%" />

<blockquote>
<p><strong>描述四次挥手过程。</strong></p>
</blockquote>
<ol>
<li>第一次挥手：客户端（也可以是服务端主动请求断开连接）发出 FIN 报文，请求断开连接。</li>
<li>第二次挥手：服务器端发出 ACK 报文，表示收到断开请求。但是此时服务器端数据没发完，可以继续发生数据。（这时客户端进入 FIN_WAIT 状态）</li>
<li>第三次挥手：服务器端数据发生完成，则向客户端发送 FIN + ACK 报文。意思是可以关闭连接了。</li>
<li>第四次挥手：客户端发送 ACK 报文，然后进入 TIME_WAIT 状态。（服务器端收到 ACK 后断开连接，客户端发送 ACK 后 2mls 时间后断开连接）</li>
</ol>
<p>注：网上有些图第一次挥手是 FIN + ACK 包，里面的 ACK 是响应上一个包的 ACK 包。</p>
<blockquote>
<p><strong>为什么挥手需要四次？</strong></p>
</blockquote>
<p>因为握手的时候没有数据，客户端发送 SYN 包后，服务端可以立刻回复 SYN + ACK 包，而挥手的时候，当服务端收到 FIN 断开连接请求的时候，只能先回复一个 ACK 包，等服务端数据发完了才接着发 FIN + ACK 包，故需要四次挥手。</p>
<blockquote>
<p><strong>为什么需要 TIME_WAIT 状态？</strong></p>
</blockquote>
<p>为了保证对方已经收到了 ACK 包，如果提前关闭的话，一旦 ACK包丢失，另一方没有收到 ACK 包，会一直停留在最后确认的状态，然后重发 FIN 包。所以要等在 2MLS 时间就是如果服务器端没有收到 ACK 包，服务器端重发 FIN 包并到达客户端的时间。（最后一个ACK包存活期 1MLS，重发 FIN 包存活期 1MLS。加起来 2MLS。）</p>
<blockquote>
<p><strong>TIME_WAIT 优化</strong></p>
</blockquote>
<p>TIME_WAIT 过多会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。一般通过设置 SO_REUSEADDR 端口重复用，断开连接后可以马上使用。</p>
<blockquote>
<p><strong>TCP 的 11 种状态</strong> </p>
</blockquote>
<p>通过上面三次握手、四次挥手图片，就可以找到 10 种状态了，还有一种 CLOSING 状态，产生的原因是客户端，服务端同时关闭（发送 FIN 包）。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
</search>
