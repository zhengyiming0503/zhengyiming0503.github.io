<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/12/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>视频播放器demo</title>
    <url>/2021/12/28/ffmpeg%E5%BA%93%E4%BD%BF%E7%94%A8-%E9%83%91%E8%89%BA%E6%98%8E/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>ffmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。它包括了目前领先的音视频编解码库libavcodec。它的音视频编解码功能非常强大，几乎囊括了现存所有的音视频编码标准。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>开发环境：Qt5.7.0 + MSVC2013<br>ffmpeg环境搭建：官网：<a href="https://ffmpeg.zeranoe.com/builds">https://ffmpeg.zeranoe.com/builds</a></p>
<p>官网提供了3个版本：<br>Static：这个版本只包含了ffmpeg.exe、ffplay.exe、ffprobe.exe三个可执行程序，没有头文件和库文件。<br>Shared：这个版本包含了ffmpeg.exe、ffplay.exe、ffprobe.exe三个可执行程序和相关动态库文件。<br>Dev：开发版，这个包含了头文件和动态库链接库。</p>
<p>我们需要下载Shared和Dev两个版本，Dev有我们程序开发需要的头文件和动态库链接库，所依赖的动态库在Shared这个版本里面，所以两个版本都要下载。</p>
<h1 id="数据格式介绍"><a href="#数据格式介绍" class="headerlink" title="数据格式介绍"></a>数据格式介绍</h1><ol>
<li><p>AVFormatContext<br>描述媒体文件或媒体流构成和基本信息（包含码流参数较多，位于：avformat.h）,封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装格式相关信息。</p>
</li>
<li><p>AVInputFormat<br>每种封装格式（例如FLV, MKV, MP4, AVI）对应一个该结构体。</p>
</li>
<li><p>AVCodecContext<br>描述编解码器上下文的数据结构，包含编解码器需要的参数信息（位于：avcodec.h）,编码器上下文结构体，保存了视频（音频）编解码相关信息。</p>
</li>
<li><p>AVStream<br>描述一个媒体流（存储视频/音频流信息的结构体，位于：avformat.h）,视频文件中每个视频（音频）流对应一个该结构体。</p>
</li>
<li><p>AVCodec<br>每种视频（音频）编解码器(例如H.264解码器)对应一个该结构体。</p>
</li>
<li><p>AVPacket<br>存储一帧压缩编码数据。</p>
</li>
<li><p>AVFrame<br>存储一帧解码后像素（采样）数据。</p>
</li>
</ol>
<h1 id="解码流程"><a href="#解码流程" class="headerlink" title="解码流程"></a>解码流程</h1><p><img src="./ffmpeg%E8%A7%A3%E7%A0%81%E6%B5%81%E7%A8%8B.png" alt="解码流程"></p>
<h1 id="简易的ffmpeg视频播放器代码"><a href="#简易的ffmpeg视频播放器代码" class="headerlink" title="简易的ffmpeg视频播放器代码"></a>简易的ffmpeg视频播放器代码</h1><pre><code>void MainWindow::on_btn_chose_file_clicked()
&#123;
    QString strFilePath = QFileDialog::getOpenFileName(
                this,
                QStringLiteral(&quot;选择要播放的文件&quot;),
                &quot;./&quot;,
                QStringLiteral(&quot;视频文件 (*.flv *.rmvb *.avi *.MP4 *.mkv *gif);;&quot;)
                +QStringLiteral(&quot;音频文件 (*.mp3 *.wma *.wav);;&quot;)
                +QStringLiteral(&quot;所有文件 (*.*)&quot;)
                );
    if(strFilePath.isEmpty())
    &#123;
        return;
    &#125;

    AVFormatContext     *pFormatCtx; //描述媒体文件或媒体流构成和基本信息（包含码流参数较多，位于：avformat.h），统领全局的结构体，保存视频文件封装格式相关信息
    AVCodecContext      *pCodecCtx;  //描述编解码器上下文的数据结构，包含编解码器需要的参数信息（位于：avcodec.h）,编码器上下文结构体，保存了视频（音频）编解码相关信息
    AVCodec             *pCodec;     //每种视频（音频）编解码器(例如H.264解码器)对应一个该结构体
    AVFrame             *pFrame;     //存储一帧解码后像素（采样）数据
    AVFrame             *pFrameRGB;  //RGB数据
    AVPacket            *pPacket;    //存储一帧解码后像素（采样）数据
    struct SwsContext   *img_convert_ctx; //用于解码后的视频格式转换
    int                  ret;
    int                  got_picture;
    unsigned char       *out_buffer;

    av_register_all();      //创建AVFormatContext对象，与码流相关的结构
    int iffpmegVer = avformat_version();
    qDebug() &lt;&lt; &quot;ffpmeg init succ. Version = &quot; &lt;&lt; iffpmegVer;

    //初始化pFormatCtx
    pFormatCtx = avformat_alloc_context();
    if(avformat_open_input(&amp;pFormatCtx, strFilePath.toStdString().c_str(), nullptr, nullptr) != 0)
    &#123;
        qDebug() &lt;&lt; &quot;could&#39;t open input stream.&quot;;
        return;
    &#125;

    //获取音视频流数据信息
    if(avformat_find_stream_info(pFormatCtx, nullptr) &lt; 0)
    &#123;
        qDebug() &lt;&lt; &quot;could&#39;t find stream information.&quot;;
        return;
    &#125;
    int videoStream = -1;
    for(int i = 0; i &lt; pFormatCtx-&gt;nb_streams; i++)
    &#123;
        //这里我们简单点，就只处理视频流，不处理音频流了
        if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)
        &#123;
            videoStream = i;
        &#125;
    &#125;
    if(videoStream &lt; 0)
    &#123;
        qDebug() &lt;&lt; &quot;could&#39;t find video stream;&quot;;
        return;
    &#125;

    //获取视频流编码结构
    pCodecCtx = pFormatCtx-&gt;streams[videoStream]-&gt;codec;
    //查找解码器
    pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);
    if(pCodec == nullptr)
    &#123;
        qDebug() &lt;&lt; &quot;could&#39;t find video codec.&quot;;
        return;
    &#125;
    //打开视频解码器
    if(avcodec_open2(pCodecCtx, pCodec, nullptr) &lt; 0)
    &#123;
        qDebug() &lt;&lt; &quot;could&#39;t open video codec&quot;;
        return;
    &#125;

    //开始解码视频
    pFrame = av_frame_alloc();
    pFrameRGB = av_frame_alloc();

    out_buffer = (unsigned char *)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_RGB32, pCodecCtx-&gt;width, pCodecCtx-&gt;height, 1)); //获取一帧图像需要的内存大小
    av_image_fill_arrays(pFrameRGB-&gt;data, pFrameRGB-&gt;linesize, out_buffer, AV_PIX_FMT_RGB32, pCodecCtx-&gt;width, pCodecCtx-&gt;height, 1);
    pPacket = (AVPacket *)av_malloc(sizeof(AVPacket));

    //初始化img_convert_ctx
    img_convert_ctx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height, AV_PIX_FMT_RGB32, SWS_BICUBIC, NULL, NULL, NULL);
    //av_read_frame读取一帧未解码的数据
    while (av_read_frame(pFormatCtx, pPacket) &gt;= 0)
    &#123;
        //如果是视频数据
        if (pPacket-&gt;stream_index == videoStream)
        &#123;
            //解码一帧视频数据
            ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, pPacket);
            if (ret &lt; 0)
            &#123;
                qDebug() &lt;&lt; &quot;decode fail.&quot;;
                return ;
            &#125;
            if (got_picture)
            &#123;
                sws_scale(img_convert_ctx, (const unsigned char* const*)pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height,
                    pFrameRGB-&gt;data, pFrameRGB-&gt;linesize);
                QImage img((uchar*)pFrameRGB-&gt;data[0],pCodecCtx-&gt;width,pCodecCtx-&gt;height,QImage::Format_RGB32);
                QPixmap pixmap = QPixmap::fromImage(img);
                int with = ui-&gt;label-&gt;width();
                int height = ui-&gt;label-&gt;height();
                QPixmap fitpixmap = pixmap.scaled(with, height, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);  // 饱满填充
                //QPixmap fitpixmap = pixmap.scaled(with, height, Qt::KeepAspectRatio, Qt::SmoothTransformation);  // 按比例缩放
                ui-&gt;label-&gt;setPixmap(fitpixmap);
                Delay(40);
            &#125;
        &#125;
        av_free_packet(pPacket);
    &#125;
    sws_freeContext(img_convert_ctx);
    av_frame_free(&amp;pFrameRGB);
    av_frame_free(&amp;pFrame);
    avcodec_close(pCodecCtx);
    avformat_close_input(&amp;pFormatCtx);
&#125;
</code></pre>
<h1 id="演示demo截图"><a href="#演示demo截图" class="headerlink" title="演示demo截图"></a>演示demo截图</h1><p><img src="./%E6%BC%94%E7%A4%BAdemo.png" alt="演示demo"></p>
<h1 id="demo链接"><a href="#demo链接" class="headerlink" title="demo链接"></a>demo链接</h1><p><a href="./ffmpeg_demo.zip">ffmpeg_demo</a> </p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
</search>
